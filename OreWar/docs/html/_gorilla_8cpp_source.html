<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OreWar: C:/Programming/Personal/OreWar/OreWar/Gorilla.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>C:/Programming/Personal/OreWar/OreWar/Gorilla.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Gorilla</span>
<a name="l00003"></a>00003 <span class="comment">    -------</span>
<a name="l00004"></a>00004 <span class="comment">    </span>
<a name="l00005"></a>00005 <span class="comment">    Copyright (c) 2010 Robin Southern</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">    Additional contributions by:</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    - Murat Sari</span>
<a name="l00010"></a>00010 <span class="comment">    - Nigel Atkinson</span>
<a name="l00011"></a>00011 <span class="comment">                                                                                  </span>
<a name="l00012"></a>00012 <span class="comment">    Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<a name="l00013"></a>00013 <span class="comment">    of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<a name="l00014"></a>00014 <span class="comment">    in the Software without restriction, including without limitation the rights</span>
<a name="l00015"></a>00015 <span class="comment">    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<a name="l00016"></a>00016 <span class="comment">    copies of the Software, and to permit persons to whom the Software is</span>
<a name="l00017"></a>00017 <span class="comment">    furnished to do so, subject to the following conditions:</span>
<a name="l00018"></a>00018 <span class="comment">                                                                                  </span>
<a name="l00019"></a>00019 <span class="comment">    The above copyright notice and this permission notice shall be included in</span>
<a name="l00020"></a>00020 <span class="comment">    all copies or substantial portions of the Software.</span>
<a name="l00021"></a>00021 <span class="comment">                                                                                  </span>
<a name="l00022"></a>00022 <span class="comment">    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00023"></a>00023 <span class="comment">    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00024"></a>00024 <span class="comment">    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l00025"></a>00025 <span class="comment">    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l00026"></a>00026 <span class="comment">    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l00027"></a>00027 <span class="comment">    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<a name="l00028"></a>00028 <span class="comment">    THE SOFTWARE. </span>
<a name="l00029"></a>00029 <span class="comment">    </span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;Gorilla.h&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#pragma warning ( disable : 4244 )</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="keyword">template</span>&lt;&gt; <a class="code" href="class_gorilla_1_1_silverback.html">Gorilla::Silverback</a>* Ogre::Singleton&lt;Gorilla::Silverback&gt;::ms_Singleton = 0;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#define PUSH_VERTEX(VERTICES, VERTEX, X, Y, UV, COLOUR)   \</span>
<a name="l00039"></a>00039 <span class="preprocessor">  VERTEX.position.x = X;                                           \</span>
<a name="l00040"></a>00040 <span class="preprocessor">  VERTEX.position.y = Y;                                           \</span>
<a name="l00041"></a>00041 <span class="preprocessor">  VERTEX.position.z = 0;                                           \</span>
<a name="l00042"></a>00042 <span class="preprocessor">  VERTEX.uv.x = UV.x;                                              \</span>
<a name="l00043"></a>00043 <span class="preprocessor">  VERTEX.uv.y = UV.y;                                              \</span>
<a name="l00044"></a>00044 <span class="preprocessor">  VERTEX.colour = COLOUR;                                          \</span>
<a name="l00045"></a>00045 <span class="preprocessor">  VERTICES.push_back(VERTEX);                                       </span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="preprocessor">#define PUSH_TRIANGLE(VERTICES, VERTEX, A, B, C, UV, COLOUR)       \</span>
<a name="l00048"></a>00048 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, A.x, A.y, UV, COLOUR) \</span>
<a name="l00049"></a>00049 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, B.x, B.y, UV, COLOUR) \</span>
<a name="l00050"></a>00050 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, C.x, C.y, UV, COLOUR) </span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#define PUSH_QUAD(VERTICES, VERTEX, POSITIONS, COLOURS, UV)   \</span>
<a name="l00053"></a>00053 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[3].x, POSITIONS[3].y, UV[3], COLOURS[3]) \</span>
<a name="l00054"></a>00054 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[1].x, POSITIONS[1].y, UV[1], COLOURS[1]) \</span>
<a name="l00055"></a>00055 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[0].x, POSITIONS[0].y, UV[0], COLOURS[0]) \</span>
<a name="l00056"></a>00056 <span class="preprocessor">     \</span>
<a name="l00057"></a>00057 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[3].x, POSITIONS[3].y, UV[3], COLOURS[3]) \</span>
<a name="l00058"></a>00058 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[2].x, POSITIONS[2].y, UV[2], COLOURS[2]) \</span>
<a name="l00059"></a>00059 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[1].x, POSITIONS[1].y, UV[1], COLOURS[1])  </span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#define PUSH_QUAD2(VERTICES, VERTEX, POSITIONS, COLOUR, UV)   \</span>
<a name="l00062"></a>00062 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[3].x, POSITIONS[3].y, UV[3], COLOUR) \</span>
<a name="l00063"></a>00063 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[1].x, POSITIONS[1].y, UV[1], COLOUR) \</span>
<a name="l00064"></a>00064 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[0].x, POSITIONS[0].y, UV[0], COLOUR) \</span>
<a name="l00065"></a>00065 <span class="preprocessor">     \</span>
<a name="l00066"></a>00066 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[3].x, POSITIONS[3].y, UV[3], COLOUR) \</span>
<a name="l00067"></a>00067 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[2].x, POSITIONS[2].y, UV[2], COLOUR) \</span>
<a name="l00068"></a>00068 <span class="preprocessor">  PUSH_VERTEX(VERTICES, VERTEX, POSITIONS[1].x, POSITIONS[1].y, UV[1], COLOUR)  </span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">namespace </span>Gorilla
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073   
<a name="l00074"></a>00074  <span class="keyword">enum</span>
<a name="l00075"></a>00075  {
<a name="l00076"></a>00076   SCREEN_RENDERQUEUE = Ogre::RENDER_QUEUE_OVERLAY
<a name="l00077"></a>00077  };
<a name="l00078"></a>00078 
<a name="l00079"></a>00079  Ogre::ColourValue rgb(Ogre::uchar r, Ogre::uchar g, Ogre::uchar b, Ogre::uchar a )
<a name="l00080"></a>00080  {
<a name="l00081"></a>00081   <span class="keyword">static</span> <span class="keyword">const</span> Ogre::Real inv255 = Ogre::Real(0.00392156863);
<a name="l00082"></a>00082   <span class="keywordflow">return</span> Ogre::ColourValue(Ogre::Real(r) * inv255, Ogre::Real(g) * inv255, Ogre::Real(b) * inv255, Ogre::Real(a) * inv255);
<a name="l00083"></a>00083  }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085  Ogre::ColourValue webcolour(Colours::Colour web_colour, Ogre::Real alpha)
<a name="l00086"></a>00086  {
<a name="l00087"></a>00087   <span class="keyword">static</span> <span class="keyword">const</span> Ogre::Real inv255 = Ogre::Real(0.00392156863);
<a name="l00088"></a>00088   Ogre::ColourValue ret;
<a name="l00089"></a>00089   ret.b = Ogre::Real(web_colour &amp; 0xFF) * inv255;
<a name="l00090"></a>00090   ret.g = Ogre::Real((web_colour &gt;&gt; 8) &amp; 0xFF) * inv255;
<a name="l00091"></a>00091   ret.r = Ogre::Real((web_colour &gt;&gt; 16) &amp; 0xFF) * inv255;
<a name="l00092"></a>00092   ret.a = alpha;
<a name="l00093"></a>00093   <span class="keywordflow">return</span> ret;
<a name="l00094"></a>00094  }
<a name="l00095"></a>00095  
<a name="l00096"></a>00096  TextureAtlas::TextureAtlas(<span class="keyword">const</span> Ogre::String&amp; gorillaFile, <span class="keyword">const</span> Ogre::String&amp; groupName)
<a name="l00097"></a>00097  {
<a name="l00098"></a>00098   
<a name="l00099"></a>00099   _reset();
<a name="l00100"></a>00100   _load(gorillaFile, groupName);
<a name="l00101"></a>00101   _calculateCoordinates();
<a name="l00102"></a>00102   _create2DMaterial();
<a name="l00103"></a>00103   _create3DMaterial();
<a name="l00104"></a>00104  }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106  TextureAtlas::~TextureAtlas()
<a name="l00107"></a>00107  {
<a name="l00108"></a>00108   <span class="keywordflow">for</span> (std::map&lt;Ogre::uint, GlyphData*&gt;::iterator it = mGlyphData.begin(); it != mGlyphData.end(); it++)
<a name="l00109"></a>00109   {
<a name="l00110"></a>00110    OGRE_DELETE (*it).second;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   
<a name="l00113"></a>00113   <span class="keywordflow">for</span> (std::map&lt;Ogre::String, Sprite*&gt;::iterator it = mSprites.begin(); it != mSprites.end(); it++)
<a name="l00114"></a>00114   {
<a name="l00115"></a>00115    OGRE_DELETE (*it).second;
<a name="l00116"></a>00116   }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118  }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120  <span class="keywordtype">void</span>  TextureAtlas::_reset()
<a name="l00121"></a>00121  {
<a name="l00122"></a>00122   <a class="code" href="class_gorilla_1_1_texture_atlas.html#ab1ddcb61a210d4175ed23baae411c826">refreshMarkupColours</a>();
<a name="l00123"></a>00123  }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125  <span class="keywordtype">void</span>  TextureAtlas::_load(<span class="keyword">const</span> Ogre::String&amp; gorillaFile, <span class="keyword">const</span> Ogre::String&amp; groupName)
<a name="l00126"></a>00126  {
<a name="l00127"></a>00127   
<a name="l00128"></a>00128   Ogre::ConfigFile f;
<a name="l00129"></a>00129   f.loadFromResourceSystem(gorillaFile, groupName, <span class="stringliteral">&quot; &quot;</span>, <span class="keyword">true</span>);
<a name="l00130"></a>00130   Ogre::ConfigFile::SectionIterator seci = f.getSectionIterator();
<a name="l00131"></a>00131   
<a name="l00132"></a>00132   Ogre::String secName;
<a name="l00133"></a>00133   <span class="keywordflow">while</span> (seci.hasMoreElements())
<a name="l00134"></a>00134   {
<a name="l00135"></a>00135    
<a name="l00136"></a>00136    secName = seci.peekNextKey();
<a name="l00137"></a>00137    Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
<a name="l00138"></a>00138    
<a name="l00139"></a>00139    Ogre::StringUtil::toLowerCase(secName);
<a name="l00140"></a>00140    
<a name="l00141"></a>00141    <span class="keywordflow">if</span> (secName == <span class="stringliteral">&quot;texture&quot;</span>)
<a name="l00142"></a>00142     _loadTexture(settings);
<a name="l00143"></a>00143    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Ogre::StringUtil::startsWith(secName, <span class="stringliteral">&quot;font.&quot;</span>, <span class="keyword">false</span>))
<a name="l00144"></a>00144    {
<a name="l00145"></a>00145     Ogre::uint index = Ogre::StringConverter::parseUnsignedInt(secName.substr(5));
<a name="l00146"></a>00146     GlyphData* glyphData = OGRE_NEW GlyphData();
<a name="l00147"></a>00147     mGlyphData[index] = glyphData;
<a name="l00148"></a>00148     
<a name="l00149"></a>00149     _loadGlyphs(settings, glyphData);
<a name="l00150"></a>00150     _loadKerning(settings, glyphData);
<a name="l00151"></a>00151     _loadVerticalOffsets(settings, glyphData);
<a name="l00152"></a>00152    }
<a name="l00153"></a>00153    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (secName == <span class="stringliteral">&quot;sprites&quot;</span>)
<a name="l00154"></a>00154     _loadSprites(settings);
<a name="l00155"></a>00155    
<a name="l00156"></a>00156   }
<a name="l00157"></a>00157   
<a name="l00158"></a>00158  }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160  <span class="keywordtype">void</span>  TextureAtlas::_loadTexture(Ogre::ConfigFile::SettingsMultiMap* settings)
<a name="l00161"></a>00161  {
<a name="l00162"></a>00162   
<a name="l00163"></a>00163   
<a name="l00164"></a>00164   Ogre::String name, data;
<a name="l00165"></a>00165   Ogre::ConfigFile::SettingsMultiMap::iterator i;
<a name="l00166"></a>00166   <span class="keywordflow">for</span> (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
<a name="l00167"></a>00167   {
<a name="l00168"></a>00168    name = i-&gt;first;
<a name="l00169"></a>00169    data = i-&gt;second;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171    <span class="keywordtype">size_t</span> comment = data.find_first_of(<span class="charliteral">&#39;#&#39;</span>);
<a name="l00172"></a>00172    <span class="keywordflow">if</span> (comment != std::string::npos)
<a name="l00173"></a>00173     data = data.substr(0, comment);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175    Ogre::StringUtil::toLowerCase(name);
<a name="l00176"></a>00176    
<a name="l00177"></a>00177    <span class="comment">// file texturename ~groupname</span>
<a name="l00178"></a>00178    <span class="comment">// &gt;  file myatlas.png</span>
<a name="l00179"></a>00179    <span class="comment">// &gt;  file myatlas.png ~loadinggroup</span>
<a name="l00180"></a>00180    <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;file&quot;</span>)
<a name="l00181"></a>00181    {
<a name="l00182"></a>00182     Ogre::String textureName = data;
<a name="l00183"></a>00183     Ogre::String groupName = Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME;
<a name="l00184"></a>00184     <span class="keywordtype">size_t</span> groupSplit = data.find_first_of(<span class="charliteral">&#39;~&#39;</span>);
<a name="l00185"></a>00185     <span class="keywordflow">if</span> (groupSplit != std::string::npos)
<a name="l00186"></a>00186     {
<a name="l00187"></a>00187      textureName = data.substr(0, groupSplit);
<a name="l00188"></a>00188      groupName = data.substr(groupSplit+1);
<a name="l00189"></a>00189      Ogre::StringUtil::trim(textureName);
<a name="l00190"></a>00190      Ogre::StringUtil::trim(groupName);
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 <span class="preprocessor">#if OGRE_VERSION &lt;= 67077 // If the version is less than or equal to 1.6.5</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>    mTexture = Ogre::TextureManager::getSingletonPtr()-&gt;getByName(data);
<a name="l00194"></a>00194 <span class="preprocessor">#else</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>    mTexture = Ogre::TextureManager::getSingletonPtr()-&gt;getByName(data, groupName);
<a name="l00196"></a>00196 <span class="preprocessor">#endif</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (mTexture.isNull())
<a name="l00198"></a>00198      mTexture = Ogre::TextureManager::getSingletonPtr()-&gt;load(textureName, groupName);
<a name="l00199"></a>00199     
<a name="l00200"></a>00200     mInverseTextureSize.x = 1.0f / mTexture-&gt;getWidth();
<a name="l00201"></a>00201     mInverseTextureSize.y = 1.0f / mTexture-&gt;getHeight();
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="keywordflow">continue</span>;
<a name="l00204"></a>00204    }
<a name="l00205"></a>00205    <span class="comment">// layer x y</span>
<a name="l00206"></a>00206    <span class="comment">// &gt;  layer 100 105</span>
<a name="l00207"></a>00207    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;whitepixel&quot;</span>)
<a name="l00208"></a>00208    {
<a name="l00209"></a>00209     mWhitePixel = Ogre::StringConverter::parseVector2(data);
<a name="l00210"></a>00210     mWhitePixel.x *= mInverseTextureSize.x;
<a name="l00211"></a>00211     mWhitePixel.y *= mInverseTextureSize.y;
<a name="l00212"></a>00212    }
<a name="l00213"></a>00213    
<a name="l00214"></a>00214   }
<a name="l00215"></a>00215   
<a name="l00216"></a>00216   
<a name="l00217"></a>00217  }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219  <span class="keywordtype">void</span>  TextureAtlas::_loadGlyphs(Ogre::ConfigFile::SettingsMultiMap* settings, GlyphData* glyphData)
<a name="l00220"></a>00220  {
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   Ogre::String name, data;
<a name="l00223"></a>00223   Ogre::ConfigFile::SettingsMultiMap::iterator i;
<a name="l00224"></a>00224   
<a name="l00225"></a>00225   Ogre::StringVector str_values;
<a name="l00226"></a>00226   Ogre::Vector2  offset(0,0);
<a name="l00227"></a>00227   <span class="keywordflow">for</span> (i = settings-&gt;begin(); i != settings-&gt;end(); ++i) 
<a name="l00228"></a>00228   {
<a name="l00229"></a>00229   
<a name="l00230"></a>00230    name = i-&gt;first;
<a name="l00231"></a>00231    data = i-&gt;second;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233    <span class="keywordtype">size_t</span> comment = data.find_first_of(<span class="charliteral">&#39;#&#39;</span>);
<a name="l00234"></a>00234    <span class="keywordflow">if</span> (comment != std::string::npos)
<a name="l00235"></a>00235     data = data.substr(0, comment);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237    Ogre::StringUtil::toLowerCase(name);
<a name="l00238"></a>00238    
<a name="l00239"></a>00239    <span class="comment">// lineheight x y</span>
<a name="l00240"></a>00240    <span class="comment">// &gt;  offset 0 80</span>
<a name="l00241"></a>00241    <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;offset&quot;</span>)
<a name="l00242"></a>00242    {
<a name="l00243"></a>00243     offset = Ogre::StringConverter::parseVector2(data);
<a name="l00244"></a>00244     <span class="keywordflow">continue</span>;
<a name="l00245"></a>00245    }
<a name="l00246"></a>00246    <span class="comment">// lineheight lineheight</span>
<a name="l00247"></a>00247    <span class="comment">// &gt;  lineheight 15</span>
<a name="l00248"></a>00248    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;lineheight&quot;</span>)
<a name="l00249"></a>00249    {
<a name="l00250"></a>00250     glyphData-&gt;mLineHeight = Ogre::StringConverter::parseReal(data);
<a name="l00251"></a>00251     <span class="keywordflow">continue</span>;
<a name="l00252"></a>00252    }
<a name="l00253"></a>00253    <span class="comment">// spacelength spacelength</span>
<a name="l00254"></a>00254    <span class="comment">// &gt;  spacelength 3</span>
<a name="l00255"></a>00255    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;spacelength&quot;</span>)
<a name="l00256"></a>00256    {
<a name="l00257"></a>00257     glyphData-&gt;mSpaceLength = Ogre::StringConverter::parseReal(data);
<a name="l00258"></a>00258     <span class="keywordflow">continue</span>;
<a name="l00259"></a>00259    }
<a name="l00260"></a>00260    <span class="comment">// spacelength spacelength</span>
<a name="l00261"></a>00261    <span class="comment">// &gt;  spacelength 3</span>
<a name="l00262"></a>00262    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;baseline&quot;</span>)
<a name="l00263"></a>00263    {
<a name="l00264"></a>00264     glyphData-&gt;mBaseline = Ogre::StringConverter::parseReal(data);
<a name="l00265"></a>00265     <span class="keywordflow">continue</span>;
<a name="l00266"></a>00266    }
<a name="l00267"></a>00267    <span class="comment">// monowidth width</span>
<a name="l00268"></a>00268    <span class="comment">// &gt;  monowidth 3</span>
<a name="l00269"></a>00269    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;monowidth&quot;</span>)
<a name="l00270"></a>00270    {
<a name="l00271"></a>00271     glyphData-&gt;mMonoWidth = Ogre::StringConverter::parseReal(data);
<a name="l00272"></a>00272     <span class="keywordflow">continue</span>;
<a name="l00273"></a>00273    }
<a name="l00274"></a>00274    <span class="comment">// range lower upper</span>
<a name="l00275"></a>00275    <span class="comment">// &gt;  range 33 126</span>
<a name="l00276"></a>00276    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;range&quot;</span>)
<a name="l00277"></a>00277    {
<a name="l00278"></a>00278     Ogre::Vector2 t = Ogre::StringConverter::parseVector2(data);
<a name="l00279"></a>00279     glyphData-&gt;mRangeBegin = t.x;
<a name="l00280"></a>00280     glyphData-&gt;mRangeEnd = t.y;
<a name="l00281"></a>00281    }
<a name="l00282"></a>00282    <span class="comment">// kerning kerning</span>
<a name="l00283"></a>00283    <span class="comment">// &gt;  kerning -1</span>
<a name="l00284"></a>00284    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;letterspacing&quot;</span>)
<a name="l00285"></a>00285    {
<a name="l00286"></a>00286     glyphData-&gt;mLetterSpacing = Ogre::StringConverter::parseReal(data);
<a name="l00287"></a>00287    }
<a name="l00288"></a>00288   }
<a name="l00289"></a>00289   
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="keywordflow">for</span> (Ogre::uint index = glyphData-&gt;mRangeBegin; index &lt;= glyphData-&gt;mRangeEnd; index++)
<a name="l00292"></a>00292   {
<a name="l00293"></a>00293    
<a name="l00294"></a>00294    Glyph* glyph = OGRE_NEW Glyph();
<a name="l00295"></a>00295    glyphData-&gt;mGlyphs.push_back(glyph);
<a name="l00296"></a>00296    
<a name="l00297"></a>00297    std::stringstream s;
<a name="l00298"></a>00298    s &lt;&lt; <span class="stringliteral">&quot;glyph_&quot;</span> &lt;&lt; index;
<a name="l00299"></a>00299    
<a name="l00300"></a>00300    i = settings-&gt;find(s.str());
<a name="l00301"></a>00301    <span class="keywordflow">if</span> (i == settings-&gt;end())
<a name="l00302"></a>00302     <span class="keywordflow">continue</span>;
<a name="l00303"></a>00303    
<a name="l00304"></a>00304    str_values = Ogre::StringUtil::split((*i).second, <span class="stringliteral">&quot; &quot;</span>, 5);
<a name="l00305"></a>00305    
<a name="l00306"></a>00306    <span class="keywordflow">if</span> (str_values.size() &lt; 4)
<a name="l00307"></a>00307    {
<a name="l00308"></a>00308     <span class="comment">//std::cout &lt;&lt; &quot;[Gorilla] Glyph #&quot; &lt;&lt; (*i).second &lt;&lt; &quot; does not have enough properties.\n&quot;;</span>
<a name="l00309"></a>00309     <span class="keywordflow">continue</span>;
<a name="l00310"></a>00310    }
<a name="l00311"></a>00311    
<a name="l00312"></a>00312    glyph-&gt;uvLeft    = offset.x + Ogre::StringConverter::parseReal(  str_values[0]  );
<a name="l00313"></a>00313    glyph-&gt;uvTop     = offset.y + Ogre::StringConverter::parseReal(  str_values[1]  );
<a name="l00314"></a>00314    glyph-&gt;uvWidth   = Ogre::StringConverter::parseReal(  str_values[2]  );
<a name="l00315"></a>00315    glyph-&gt;uvHeight  = Ogre::StringConverter::parseReal(  str_values[3]  );
<a name="l00316"></a>00316    glyph-&gt;uvRight   = glyph-&gt;uvLeft + glyph-&gt;uvWidth;
<a name="l00317"></a>00317    glyph-&gt;uvBottom  = glyph-&gt;uvTop + glyph-&gt;uvHeight;
<a name="l00318"></a>00318    
<a name="l00319"></a>00319    <span class="keywordflow">if</span> (str_values.size() == 5)
<a name="l00320"></a>00320      glyph-&gt;glyphAdvance = Ogre::StringConverter::parseInt(  str_values[4]  );
<a name="l00321"></a>00321    <span class="keywordflow">else</span>
<a name="l00322"></a>00322     glyph-&gt;glyphAdvance = glyph-&gt;uvWidth;
<a name="l00323"></a>00323    
<a name="l00324"></a>00324    
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326   
<a name="l00327"></a>00327  }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329  <span class="keywordtype">void</span>  TextureAtlas::_loadKerning(Ogre::ConfigFile::SettingsMultiMap* settings, GlyphData* glyphData)
<a name="l00330"></a>00330  {
<a name="l00331"></a>00331   
<a name="l00332"></a>00332   Ogre::String left_name, data;
<a name="l00333"></a>00333   Ogre::ConfigFile::SettingsMultiMap::iterator i;
<a name="l00334"></a>00334   Ogre::uint left_glyph_id;
<a name="l00335"></a>00335   Ogre::uint right_glyph_id;
<a name="l00336"></a>00336   <span class="keywordtype">int</span> kerning;
<a name="l00337"></a>00337   Ogre::StringVector str_values;
<a name="l00338"></a>00338   
<a name="l00339"></a>00339   <span class="keywordflow">for</span> (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
<a name="l00340"></a>00340   {
<a name="l00341"></a>00341    
<a name="l00342"></a>00342    left_name = i-&gt;first;
<a name="l00343"></a>00343    data = i-&gt;second;
<a name="l00344"></a>00344    Ogre::StringUtil::toLowerCase(left_name);
<a name="l00345"></a>00345    
<a name="l00346"></a>00346    <span class="keywordflow">if</span> (left_name.substr(0,6) != <span class="stringliteral">&quot;kerning_&quot;</span>)
<a name="l00347"></a>00347     <span class="keywordflow">continue</span>;
<a name="l00348"></a>00348    
<a name="l00349"></a>00349    <span class="keywordtype">size_t</span> comment = data.find_first_of(<span class="charliteral">&#39;#&#39;</span>);
<a name="l00350"></a>00350    <span class="keywordflow">if</span> (comment != std::string::npos)
<a name="l00351"></a>00351     data = data.substr(0, comment);
<a name="l00352"></a>00352    
<a name="l00353"></a>00353    left_name = left_name.substr(8); <span class="comment">// chop of kerning_</span>
<a name="l00354"></a>00354    left_glyph_id = Ogre::StringConverter::parseUnsignedInt(left_name);
<a name="l00355"></a>00355    
<a name="l00356"></a>00356    str_values = Ogre::StringUtil::split(data, <span class="stringliteral">&quot; &quot;</span>, 2);
<a name="l00357"></a>00357    
<a name="l00358"></a>00358    <span class="keywordflow">if</span> (str_values.size() != 2)
<a name="l00359"></a>00359    {
<a name="l00360"></a>00360     <span class="comment">//std::cout &lt;&lt; &quot;[Gorilla] Kerning Glyph #&quot; &lt;&lt; left_name &lt;&lt; &quot; does not have enough properties\n&quot;;</span>
<a name="l00361"></a>00361     <span class="keywordflow">continue</span>;
<a name="l00362"></a>00362    }
<a name="l00363"></a>00363    
<a name="l00364"></a>00364    right_glyph_id = Ogre::StringConverter::parseUnsignedInt(str_values[0]);
<a name="l00365"></a>00365    kerning = Ogre::StringConverter::parseInt(str_values[1]);
<a name="l00366"></a>00366    
<a name="l00367"></a>00367    
<a name="l00368"></a>00368    glyphData-&gt;mGlyphs[right_glyph_id - glyphData-&gt;mRangeBegin]-&gt;kerning.push_back(Kerning(left_glyph_id, kerning));
<a name="l00369"></a>00369    
<a name="l00370"></a>00370   }
<a name="l00371"></a>00371   
<a name="l00372"></a>00372  }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374  <span class="keywordtype">void</span>  TextureAtlas::_loadVerticalOffsets(Ogre::ConfigFile::SettingsMultiMap* settings, GlyphData* glyphData)
<a name="l00375"></a>00375  {
<a name="l00376"></a>00376   
<a name="l00377"></a>00377   Ogre::String left_name, data;
<a name="l00378"></a>00378   Ogre::ConfigFile::SettingsMultiMap::iterator i;
<a name="l00379"></a>00379   Ogre::uint glyph_id;
<a name="l00380"></a>00380   <span class="keywordtype">int</span> verticalOffset;
<a name="l00381"></a>00381   
<a name="l00382"></a>00382   <span class="keywordflow">for</span> (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
<a name="l00383"></a>00383   {
<a name="l00384"></a>00384    
<a name="l00385"></a>00385    left_name = i-&gt;first;
<a name="l00386"></a>00386    data = i-&gt;second;
<a name="l00387"></a>00387    Ogre::StringUtil::toLowerCase(left_name);
<a name="l00388"></a>00388    
<a name="l00389"></a>00389    <span class="keywordflow">if</span> (left_name.substr(0,15) != <span class="stringliteral">&quot;verticaloffset_&quot;</span>)
<a name="l00390"></a>00390     <span class="keywordflow">continue</span>;
<a name="l00391"></a>00391    
<a name="l00392"></a>00392    <span class="keywordtype">size_t</span> comment = data.find_first_of(<span class="charliteral">&#39;#&#39;</span>);
<a name="l00393"></a>00393    <span class="keywordflow">if</span> (comment != std::string::npos)
<a name="l00394"></a>00394     data = data.substr(0, comment);
<a name="l00395"></a>00395    
<a name="l00396"></a>00396    left_name = left_name.substr(15); <span class="comment">// chop of verticalOffset_</span>
<a name="l00397"></a>00397    glyph_id = Ogre::StringConverter::parseUnsignedInt(left_name);
<a name="l00398"></a>00398    
<a name="l00399"></a>00399    verticalOffset = Ogre::StringConverter::parseInt(data);
<a name="l00400"></a>00400    
<a name="l00401"></a>00401    glyphData-&gt;getGlyph(glyph_id)-&gt;verticalOffset = verticalOffset;
<a name="l00402"></a>00402    
<a name="l00403"></a>00403   }
<a name="l00404"></a>00404   
<a name="l00405"></a>00405  }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407  <span class="keywordtype">void</span>  TextureAtlas::_loadSprites(Ogre::ConfigFile::SettingsMultiMap* settings)
<a name="l00408"></a>00408  {
<a name="l00409"></a>00409   
<a name="l00410"></a>00410   Ogre::String sprite_name, data;
<a name="l00411"></a>00411   Ogre::ConfigFile::SettingsMultiMap::iterator i;
<a name="l00412"></a>00412   
<a name="l00413"></a>00413   Ogre::StringVector str_values;
<a name="l00414"></a>00414   <span class="keywordflow">for</span> (i = settings-&gt;begin(); i != settings-&gt;end(); ++i)
<a name="l00415"></a>00415   {
<a name="l00416"></a>00416   
<a name="l00417"></a>00417    sprite_name = i-&gt;first;
<a name="l00418"></a>00418    data = i-&gt;second;
<a name="l00419"></a>00419    
<a name="l00420"></a>00420    <span class="keywordtype">size_t</span> comment = data.find_first_of(<span class="charliteral">&#39;#&#39;</span>);
<a name="l00421"></a>00421    <span class="keywordflow">if</span> (comment != std::string::npos)
<a name="l00422"></a>00422     data = data.substr(0, comment);
<a name="l00423"></a>00423    
<a name="l00424"></a>00424    str_values = Ogre::StringUtil::split(data, <span class="stringliteral">&quot; &quot;</span>, 4);
<a name="l00425"></a>00425    
<a name="l00426"></a>00426    <span class="keywordflow">if</span> (str_values.size() != 4)
<a name="l00427"></a>00427    {
<a name="l00428"></a>00428     <span class="comment">//std::cout &lt;&lt; &quot;[Gorilla] Sprite #&quot; &lt;&lt; sprite_name &lt;&lt; &quot; does not have enough properties\n&quot; &lt;&lt; data &lt;&lt; &quot;\n&quot;;</span>
<a name="l00429"></a>00429     <span class="keywordflow">continue</span>;
<a name="l00430"></a>00430    }
<a name="l00431"></a>00431    
<a name="l00432"></a>00432    Sprite* sprite = OGRE_NEW Sprite();
<a name="l00433"></a>00433    
<a name="l00434"></a>00434    sprite-&gt;uvLeft = Ogre::StringConverter::parseUnsignedInt(str_values[0]);
<a name="l00435"></a>00435    sprite-&gt;uvTop = Ogre::StringConverter::parseUnsignedInt(str_values[1]);
<a name="l00436"></a>00436    sprite-&gt;spriteWidth = Ogre::StringConverter::parseUnsignedInt(str_values[2]);
<a name="l00437"></a>00437    sprite-&gt;spriteHeight = Ogre::StringConverter::parseUnsignedInt(str_values[3]);
<a name="l00438"></a>00438    
<a name="l00439"></a>00439    mSprites[sprite_name] = sprite;
<a name="l00440"></a>00440    
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442   
<a name="l00443"></a>00443  }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 
<a name="l00446"></a>00446  Ogre::MaterialPtr TextureAtlas::createOrGet2DMasterMaterial()
<a name="l00447"></a>00447  {
<a name="l00448"></a>00448   Ogre::MaterialPtr d2Material = Ogre::MaterialManager::getSingletonPtr()-&gt;getByName(<span class="stringliteral">&quot;Gorilla2D&quot;</span>);
<a name="l00449"></a>00449   <span class="keywordflow">if</span> (d2Material.isNull() == <span class="keyword">false</span>)
<a name="l00450"></a>00450   {
<a name="l00451"></a>00451     Ogre::Pass* pass = d2Material-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">if</span>(pass-&gt;hasVertexProgram())
<a name="l00454"></a>00454     {
<a name="l00455"></a>00455       Ogre::GpuProgramPtr gpuPtr = pass-&gt;getVertexProgram();
<a name="l00456"></a>00456       gpuPtr-&gt;load();
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     <span class="keywordflow">if</span>(pass-&gt;hasFragmentProgram())
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461       Ogre::GpuProgramPtr gpuPtr = pass-&gt;getFragmentProgram();
<a name="l00462"></a>00462       gpuPtr-&gt;load();
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <span class="keywordflow">return</span> d2Material;
<a name="l00466"></a>00466   }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   d2Material = Ogre::MaterialManager::getSingletonPtr()-&gt;create(<span class="stringliteral">&quot;Gorilla2D&quot;</span>, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
<a name="l00469"></a>00469   Ogre::Pass* pass = d2Material-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00470"></a>00470   pass-&gt;setCullingMode(Ogre::CULL_NONE);
<a name="l00471"></a>00471   pass-&gt;setDepthCheckEnabled(<span class="keyword">false</span>);
<a name="l00472"></a>00472   pass-&gt;setDepthWriteEnabled(<span class="keyword">false</span>);
<a name="l00473"></a>00473   pass-&gt;setLightingEnabled(<span class="keyword">false</span>);
<a name="l00474"></a>00474   pass-&gt;setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);
<a name="l00475"></a>00475   
<a name="l00476"></a>00476   Ogre::TextureUnitState* texUnit = pass-&gt;createTextureUnitState();
<a name="l00477"></a>00477   texUnit-&gt;setTextureAddressingMode(Ogre::TextureUnitState::TAM_CLAMP);
<a name="l00478"></a>00478   texUnit-&gt;setTextureFiltering(Ogre::FO_NONE, Ogre::FO_NONE, Ogre::FO_NONE);
<a name="l00479"></a>00479   
<a name="l00480"></a>00480   <span class="keywordflow">return</span> d2Material;
<a name="l00481"></a>00481  }
<a name="l00482"></a>00482  
<a name="l00483"></a>00483  Ogre::MaterialPtr TextureAtlas::createOrGet3DMasterMaterial()
<a name="l00484"></a>00484  {  
<a name="l00485"></a>00485   Ogre::MaterialPtr d3Material = Ogre::MaterialManager::getSingletonPtr()-&gt;getByName(<span class="stringliteral">&quot;Gorilla3D&quot;</span>);
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (d3Material.isNull() == <span class="keyword">false</span>)
<a name="l00487"></a>00487   {
<a name="l00488"></a>00488     Ogre::Pass* pass = d3Material-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="keywordflow">if</span>(pass-&gt;hasVertexProgram())
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       Ogre::GpuProgramPtr gpuPtr = pass-&gt;getVertexProgram();
<a name="l00493"></a>00493       gpuPtr-&gt;load();
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keywordflow">if</span>(pass-&gt;hasFragmentProgram())
<a name="l00497"></a>00497     {
<a name="l00498"></a>00498       Ogre::GpuProgramPtr gpuPtr = pass-&gt;getFragmentProgram();
<a name="l00499"></a>00499       gpuPtr-&gt;load();
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordflow">return</span> d3Material;
<a name="l00503"></a>00503   }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505   d3Material = Ogre::MaterialManager::getSingletonPtr()-&gt;create(<span class="stringliteral">&quot;Gorilla3D&quot;</span>, Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
<a name="l00506"></a>00506   Ogre::Pass* pass = d3Material-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00507"></a>00507   pass-&gt;setCullingMode(Ogre::CULL_NONE);
<a name="l00508"></a>00508   pass-&gt;setDepthCheckEnabled(<span class="keyword">false</span>);
<a name="l00509"></a>00509   pass-&gt;setDepthWriteEnabled(<span class="keyword">false</span>);
<a name="l00510"></a>00510   pass-&gt;setLightingEnabled(<span class="keyword">false</span>);
<a name="l00511"></a>00511   pass-&gt;setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   Ogre::TextureUnitState* texUnit = pass-&gt;createTextureUnitState();
<a name="l00514"></a>00514   texUnit-&gt;setTextureAddressingMode(Ogre::TextureUnitState::TAM_CLAMP);
<a name="l00515"></a>00515   texUnit-&gt;setTextureFiltering(Ogre::FO_ANISOTROPIC, Ogre::FO_ANISOTROPIC, Ogre::FO_ANISOTROPIC);
<a name="l00516"></a>00516   
<a name="l00517"></a>00517   <span class="keywordflow">return</span> d3Material;
<a name="l00518"></a>00518  }
<a name="l00519"></a>00519  
<a name="l00520"></a>00520 
<a name="l00521"></a>00521  <span class="keywordtype">void</span>  TextureAtlas::_create2DMaterial()
<a name="l00522"></a>00522  {
<a name="l00523"></a>00523   
<a name="l00524"></a>00524   std::string matName = <span class="stringliteral">&quot;Gorilla2D.&quot;</span> + mTexture-&gt;getName();
<a name="l00525"></a>00525   m2DMaterial = Ogre::MaterialManager::getSingletonPtr()-&gt;getByName(matName);
<a name="l00526"></a>00526   
<a name="l00527"></a>00527   <span class="keywordflow">if</span> (m2DMaterial.isNull() == <span class="keyword">false</span>)
<a name="l00528"></a>00528    <span class="keywordflow">return</span>;
<a name="l00529"></a>00529   
<a name="l00530"></a>00530   
<a name="l00531"></a>00531   m2DMaterial = createOrGet2DMasterMaterial()-&gt;clone(matName);
<a name="l00532"></a>00532   m2DPass = m2DMaterial-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00533"></a>00533   m2DPass-&gt;getTextureUnitState(0)-&gt;setTextureName(mTexture-&gt;getName());
<a name="l00534"></a>00534   
<a name="l00535"></a>00535  }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537  <span class="keywordtype">void</span>  TextureAtlas::_create3DMaterial()
<a name="l00538"></a>00538  {
<a name="l00539"></a>00539   
<a name="l00540"></a>00540   std::string matName = <span class="stringliteral">&quot;Gorilla3D.&quot;</span> + mTexture-&gt;getName();
<a name="l00541"></a>00541   m3DMaterial = Ogre::MaterialManager::getSingletonPtr()-&gt;getByName(matName);
<a name="l00542"></a>00542   
<a name="l00543"></a>00543   <span class="keywordflow">if</span> (m3DMaterial.isNull() == <span class="keyword">false</span>)
<a name="l00544"></a>00544    <span class="keywordflow">return</span>;
<a name="l00545"></a>00545   
<a name="l00546"></a>00546   
<a name="l00547"></a>00547   m3DMaterial = createOrGet3DMasterMaterial()-&gt;clone(matName);
<a name="l00548"></a>00548   m3DPass = m3DMaterial-&gt;getTechnique(0)-&gt;getPass(0);
<a name="l00549"></a>00549   m3DPass-&gt;getTextureUnitState(0)-&gt;setTextureName(mTexture-&gt;getName());
<a name="l00550"></a>00550   
<a name="l00551"></a>00551  }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553  <span class="keywordtype">void</span>  TextureAtlas::_calculateCoordinates()
<a name="l00554"></a>00554  {
<a name="l00555"></a>00555   
<a name="l00556"></a>00556   Ogre::RenderSystem* rs = Ogre::Root::getSingletonPtr()-&gt;getRenderSystem();
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   Ogre::Real texelX =  rs-&gt;getHorizontalTexelOffset(),
<a name="l00559"></a>00559              texelY =  rs-&gt;getVerticalTexelOffset();
<a name="l00560"></a>00560   
<a name="l00561"></a>00561   <span class="keywordflow">for</span> (std::map&lt;Ogre::uint, GlyphData*&gt;::iterator gd_it = mGlyphData.begin(); gd_it != mGlyphData.end(); gd_it++)
<a name="l00562"></a>00562   {
<a name="l00563"></a>00563     <span class="keywordflow">for</span>(std::vector&lt;Glyph*&gt;::iterator it = (*gd_it).second-&gt;mGlyphs.begin(); it != (*gd_it).second-&gt;mGlyphs.end(); it++)
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565      
<a name="l00566"></a>00566      (*it)-&gt;uvLeft        -= texelX;
<a name="l00567"></a>00567      (*it)-&gt;uvTop         -= texelY;
<a name="l00568"></a>00568      (*it)-&gt;uvRight       += texelX;
<a name="l00569"></a>00569      (*it)-&gt;uvBottom      += texelY;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571      (*it)-&gt;uvLeft        *= mInverseTextureSize.x;
<a name="l00572"></a>00572      (*it)-&gt;uvTop         *= mInverseTextureSize.y;
<a name="l00573"></a>00573      (*it)-&gt;uvRight       *= mInverseTextureSize.x;
<a name="l00574"></a>00574      (*it)-&gt;uvBottom      *= mInverseTextureSize.y;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576      (*it)-&gt;texCoords[TopLeft].x = (*it)-&gt;uvLeft;
<a name="l00577"></a>00577      (*it)-&gt;texCoords[TopLeft].y = (*it)-&gt;uvTop;
<a name="l00578"></a>00578      (*it)-&gt;texCoords[TopRight].x = (*it)-&gt;uvRight;
<a name="l00579"></a>00579      (*it)-&gt;texCoords[TopRight].y = (*it)-&gt;uvTop;
<a name="l00580"></a>00580      (*it)-&gt;texCoords[BottomRight].x = (*it)-&gt;uvRight;
<a name="l00581"></a>00581      (*it)-&gt;texCoords[BottomRight].y = (*it)-&gt;uvBottom;
<a name="l00582"></a>00582      (*it)-&gt;texCoords[BottomLeft].x = (*it)-&gt;uvLeft;
<a name="l00583"></a>00583      (*it)-&gt;texCoords[BottomLeft].y = (*it)-&gt;uvBottom;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585      (*it)-&gt;glyphWidth     = (*it)-&gt;uvWidth;
<a name="l00586"></a>00586      (*it)-&gt;glyphHeight    = (*it)-&gt;uvHeight;
<a name="l00587"></a>00587      
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590   
<a name="l00591"></a>00591   <span class="keywordflow">for</span> (std::map&lt;Ogre::String, Sprite*&gt;::iterator it = mSprites.begin(); it != mSprites.end(); it++)
<a name="l00592"></a>00592   {
<a name="l00593"></a>00593    (*it).second-&gt;uvRight    = (*it).second-&gt;uvLeft + (*it).second-&gt;spriteWidth;
<a name="l00594"></a>00594    (*it).second-&gt;uvBottom   = (*it).second-&gt;uvTop  + (*it).second-&gt;spriteHeight;
<a name="l00595"></a>00595    
<a name="l00596"></a>00596    (*it).second-&gt;uvLeft    *= mInverseTextureSize.x;
<a name="l00597"></a>00597    (*it).second-&gt;uvTop     *= mInverseTextureSize.y;
<a name="l00598"></a>00598    (*it).second-&gt;uvRight   *= mInverseTextureSize.x;
<a name="l00599"></a>00599    (*it).second-&gt;uvBottom  *= mInverseTextureSize.y;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601    (*it).second-&gt;texCoords[TopLeft].x = (*it).second-&gt;uvLeft;
<a name="l00602"></a>00602    (*it).second-&gt;texCoords[TopLeft].y = (*it).second-&gt;uvTop;
<a name="l00603"></a>00603    (*it).second-&gt;texCoords[TopRight].x = (*it).second-&gt;uvRight;
<a name="l00604"></a>00604    (*it).second-&gt;texCoords[TopRight].y = (*it).second-&gt;uvTop;
<a name="l00605"></a>00605    (*it).second-&gt;texCoords[BottomRight].x = (*it).second-&gt;uvRight;
<a name="l00606"></a>00606    (*it).second-&gt;texCoords[BottomRight].y = (*it).second-&gt;uvBottom;
<a name="l00607"></a>00607    (*it).second-&gt;texCoords[BottomLeft].x = (*it).second-&gt;uvLeft;
<a name="l00608"></a>00608    (*it).second-&gt;texCoords[BottomLeft].y = (*it).second-&gt;uvBottom;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   }
<a name="l00611"></a>00611   
<a name="l00612"></a>00612  }
<a name="l00613"></a>00613 
<a name="l00614"></a><a class="code" href="class_gorilla_1_1_texture_atlas.html#ab1ddcb61a210d4175ed23baae411c826">00614</a>  <span class="keywordtype">void</span>   <a class="code" href="class_gorilla_1_1_texture_atlas.html#ab1ddcb61a210d4175ed23baae411c826">TextureAtlas::refreshMarkupColours</a>()
<a name="l00615"></a>00615  {
<a name="l00616"></a>00616   mMarkupColour[0] = rgb(255, 255, 255);
<a name="l00617"></a>00617   mMarkupColour[1] = rgb(0, 0, 0);
<a name="l00618"></a>00618   mMarkupColour[2] = rgb(204, 204, 204);
<a name="l00619"></a>00619   mMarkupColour[3] = rgb(254, 220, 129);
<a name="l00620"></a>00620   mMarkupColour[4] = rgb(254, 138, 129);
<a name="l00621"></a>00621   mMarkupColour[5] = rgb(123, 236, 110);
<a name="l00622"></a>00622   mMarkupColour[6] = rgb(44,  192, 171);
<a name="l00623"></a>00623   mMarkupColour[7] = rgb(199, 93,  142);
<a name="l00624"></a>00624   mMarkupColour[8] = rgb(254, 254, 254);
<a name="l00625"></a>00625   mMarkupColour[9] = rgb(13,  13,  13);
<a name="l00626"></a>00626  }
<a name="l00627"></a>00627 
<a name="l00628"></a><a class="code" href="class_gorilla_1_1_texture_atlas.html#ad52235ee0430f169ae8065ef163e8fbd">00628</a>  <span class="keywordtype">void</span>   <a class="code" href="class_gorilla_1_1_texture_atlas.html#ad52235ee0430f169ae8065ef163e8fbd">TextureAtlas::setMarkupColour</a>(Ogre::uint index, <span class="keyword">const</span> Ogre::ColourValue&amp; colour)
<a name="l00629"></a>00629  { 
<a name="l00630"></a>00630   <span class="keywordflow">if</span> (index &gt; 9)
<a name="l00631"></a>00631    <span class="keywordflow">return</span>;
<a name="l00632"></a>00632   
<a name="l00633"></a>00633   mMarkupColour[index] = colour;
<a name="l00634"></a>00634  }
<a name="l00635"></a>00635 
<a name="l00636"></a><a class="code" href="class_gorilla_1_1_texture_atlas.html#af9fbcae388ba45eb44566cffb8e22bc6">00636</a>  Ogre::ColourValue  <a class="code" href="class_gorilla_1_1_texture_atlas.html#af9fbcae388ba45eb44566cffb8e22bc6">TextureAtlas::getMarkupColour</a>(Ogre::uint index)
<a name="l00637"></a>00637  {
<a name="l00638"></a>00638   <span class="keywordflow">if</span> (index &gt; 9)
<a name="l00639"></a>00639    <span class="keywordflow">return</span> Ogre::ColourValue::White;
<a name="l00640"></a>00640   
<a name="l00641"></a>00641   <span class="keywordflow">return</span> mMarkupColour[index];
<a name="l00642"></a>00642  }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644  GlyphData::GlyphData()
<a name="l00645"></a>00645  : mRangeBegin(0), 
<a name="l00646"></a>00646    mRangeEnd(0),
<a name="l00647"></a>00647    mSpaceLength(0),
<a name="l00648"></a>00648    mLineHeight(0),
<a name="l00649"></a>00649    mBaseline(0),
<a name="l00650"></a>00650    mLetterSpacing(0),
<a name="l00651"></a>00651    mMonoWidth(0)
<a name="l00652"></a>00652  {
<a name="l00653"></a>00653  }
<a name="l00654"></a>00654  
<a name="l00655"></a>00655  GlyphData::~GlyphData()
<a name="l00656"></a>00656  {
<a name="l00657"></a>00657   
<a name="l00658"></a>00658   <span class="keywordflow">for</span> (std::vector&lt;Glyph*&gt;::iterator it = mGlyphs.begin(); it != mGlyphs.end(); it++)
<a name="l00659"></a>00659   {
<a name="l00660"></a>00660    OGRE_DELETE (*it);
<a name="l00661"></a>00661   }
<a name="l00662"></a>00662   
<a name="l00663"></a>00663  }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="class_gorilla_1_1_silverback.html#aed881ea7ac9874db9539922ece58632f">00666</a>  <a class="code" href="class_gorilla_1_1_silverback.html#aed881ea7ac9874db9539922ece58632f">Silverback::Silverback</a>()
<a name="l00667"></a>00667  {
<a name="l00668"></a>00668   
<a name="l00669"></a>00669   Ogre::Root::getSingletonPtr()-&gt;addFrameListener(<span class="keyword">this</span>);
<a name="l00670"></a>00670   
<a name="l00671"></a>00671  }
<a name="l00672"></a>00672 
<a name="l00673"></a><a class="code" href="class_gorilla_1_1_silverback.html#ab1596997b9b9c384f52395fb0b3324c6">00673</a>  <a class="code" href="class_gorilla_1_1_silverback.html#ab1596997b9b9c384f52395fb0b3324c6">Silverback::~Silverback</a>()
<a name="l00674"></a>00674  {
<a name="l00675"></a>00675   
<a name="l00676"></a>00676   Ogre::Root::getSingletonPtr()-&gt;removeFrameListener(<span class="keyword">this</span>);
<a name="l00677"></a>00677   
<a name="l00678"></a>00678   <span class="comment">// Delete Screens.</span>
<a name="l00679"></a>00679   <span class="keywordflow">for</span> (std::vector&lt;Screen*&gt;::iterator it = mScreens.begin(); it != mScreens.end(); it++)
<a name="l00680"></a>00680    OGRE_DELETE (*it);
<a name="l00681"></a>00681   
<a name="l00682"></a>00682   mScreens.clear();
<a name="l00683"></a>00683   
<a name="l00684"></a>00684   <span class="comment">// Delete Screens.</span>
<a name="l00685"></a>00685   <span class="keywordflow">for</span> (std::vector&lt;ScreenRenderable*&gt;::iterator it = mScreenRenderables.begin(); it != mScreenRenderables.end(); it++)
<a name="l00686"></a>00686    OGRE_DELETE (*it);
<a name="l00687"></a>00687   
<a name="l00688"></a>00688   mScreenRenderables.clear();
<a name="l00689"></a>00689   
<a name="l00690"></a>00690   <span class="comment">// Delete Atlases.</span>
<a name="l00691"></a>00691   <span class="keywordflow">for</span> (std::map&lt;Ogre::String, TextureAtlas*&gt;::iterator it = mAtlases.begin(); it != mAtlases.end(); it++)
<a name="l00692"></a>00692    OGRE_DELETE (*it).second;
<a name="l00693"></a>00693   mAtlases.clear();
<a name="l00694"></a>00694   
<a name="l00695"></a>00695  }
<a name="l00696"></a>00696 
<a name="l00697"></a><a class="code" href="class_gorilla_1_1_silverback.html#a702ca7f5a82ea99e7467bba54e6aa3e7">00697</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_silverback.html#a702ca7f5a82ea99e7467bba54e6aa3e7">Silverback::loadAtlas</a>(<span class="keyword">const</span> Ogre::String &amp;name, <span class="keyword">const</span> Ogre::String &amp;group)
<a name="l00698"></a>00698  {
<a name="l00699"></a>00699   <a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>* atlas = OGRE_NEW <a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>(name + <span class="stringliteral">&quot;.gorilla&quot;</span>, group);
<a name="l00700"></a>00700   mAtlases[name] = atlas;
<a name="l00701"></a>00701  }
<a name="l00702"></a>00702 
<a name="l00703"></a><a class="code" href="class_gorilla_1_1_silverback.html#aea736c34b584dce837c55d550c11d030">00703</a>  <a class="code" href="class_gorilla_1_1_screen.html">Screen</a>* <a class="code" href="class_gorilla_1_1_silverback.html#aea736c34b584dce837c55d550c11d030">Silverback::createScreen</a>(Ogre::Viewport* viewport, <span class="keyword">const</span> Ogre::String&amp; atlas_name)
<a name="l00704"></a>00704  {
<a name="l00705"></a>00705   <a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>* atlas = (*mAtlases.find(atlas_name)).second;
<a name="l00706"></a>00706   <a class="code" href="class_gorilla_1_1_screen.html">Screen</a>* screen = OGRE_NEW <a class="code" href="class_gorilla_1_1_screen.html">Screen</a>(viewport, atlas);
<a name="l00707"></a>00707   mScreens.push_back(screen);
<a name="l00708"></a>00708   <span class="keywordflow">return</span> screen;
<a name="l00709"></a>00709  }
<a name="l00710"></a>00710 
<a name="l00711"></a><a class="code" href="class_gorilla_1_1_silverback.html#a644be17e6fd266d21edd1ec959c2baa9">00711</a>  <a class="code" href="class_gorilla_1_1_screen_renderable.html">ScreenRenderable</a>* <a class="code" href="class_gorilla_1_1_silverback.html#a644be17e6fd266d21edd1ec959c2baa9">Silverback::createScreenRenderable</a>(<span class="keyword">const</span> Ogre::Vector2&amp; maxSize, <span class="keyword">const</span> Ogre::String&amp; atlas_name)
<a name="l00712"></a>00712  {
<a name="l00713"></a>00713   <a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>* atlas = (*mAtlases.find(atlas_name)).second;
<a name="l00714"></a>00714   <a class="code" href="class_gorilla_1_1_screen_renderable.html">ScreenRenderable</a>* screen = OGRE_NEW <a class="code" href="class_gorilla_1_1_screen_renderable.html">ScreenRenderable</a>(maxSize, atlas);
<a name="l00715"></a>00715   mScreenRenderables.push_back(screen);
<a name="l00716"></a>00716   <span class="keywordflow">return</span> screen;
<a name="l00717"></a>00717  }
<a name="l00718"></a>00718  
<a name="l00719"></a><a class="code" href="class_gorilla_1_1_silverback.html#a212af4606fd8439b8b32a1af6164fbe8">00719</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_silverback.html#a212af4606fd8439b8b32a1af6164fbe8">Silverback::destroyScreen</a>(<a class="code" href="class_gorilla_1_1_screen.html">Screen</a>* screen)
<a name="l00720"></a>00720  {
<a name="l00721"></a>00721   <span class="keywordflow">if</span> (screen == 0)
<a name="l00722"></a>00722    <span class="keywordflow">return</span>;
<a name="l00723"></a>00723   
<a name="l00724"></a>00724   mScreens.erase(std::find(mScreens.begin(), mScreens.end(), screen));
<a name="l00725"></a>00725   OGRE_DELETE screen;
<a name="l00726"></a>00726  }
<a name="l00727"></a>00727  
<a name="l00728"></a><a class="code" href="class_gorilla_1_1_silverback.html#a292cdecbfc3ce8cf5d7b35fda45af855">00728</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_silverback.html#a292cdecbfc3ce8cf5d7b35fda45af855">Silverback::destroyScreenRenderable</a>(<a class="code" href="class_gorilla_1_1_screen_renderable.html">ScreenRenderable</a>* screen_renderables)
<a name="l00729"></a>00729  {
<a name="l00730"></a>00730   mScreenRenderables.erase(std::find(mScreenRenderables.begin(), mScreenRenderables.end(), screen_renderables));
<a name="l00731"></a>00731   OGRE_DELETE screen_renderables;
<a name="l00732"></a>00732  }
<a name="l00733"></a>00733 
<a name="l00734"></a><a class="code" href="class_gorilla_1_1_silverback.html#a953980f1e28a2b9940c7186b51586b2b">00734</a>  <span class="keywordtype">bool</span> <a class="code" href="class_gorilla_1_1_silverback.html#a953980f1e28a2b9940c7186b51586b2b">Silverback::frameStarted</a>(<span class="keyword">const</span> Ogre::FrameEvent&amp; evt)
<a name="l00735"></a>00735  {
<a name="l00736"></a>00736   <span class="keywordflow">for</span> (std::vector&lt;ScreenRenderable*&gt;::iterator it = mScreenRenderables.begin(); it != mScreenRenderables.end(); it++)
<a name="l00737"></a>00737    (*it)-&gt;frameStarted();
<a name="l00738"></a>00738   
<a name="l00739"></a>00739   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00740"></a>00740  }
<a name="l00741"></a>00741  
<a name="l00742"></a>00742  LayerContainer::LayerContainer(<a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>* atlas)
<a name="l00743"></a>00743  : mAtlas(atlas), mIndexRedrawAll(false)
<a name="l00744"></a>00744  {
<a name="l00745"></a>00745  }
<a name="l00746"></a>00746  
<a name="l00747"></a>00747  LayerContainer::~LayerContainer()
<a name="l00748"></a>00748  {
<a name="l00749"></a>00749   <span class="keywordflow">for</span> (std::vector&lt;Layer*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.begin(); it != <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.end(); it++)
<a name="l00750"></a>00750    OGRE_DELETE (*it);
<a name="l00751"></a>00751   
<a name="l00752"></a>00752   <a class="code" href="class_gorilla_1_1_layer_container.html#a00c30924b3036d71fcf12b3ebaa4bee8">_destroyVertexBuffer</a>();
<a name="l00753"></a>00753  }
<a name="l00754"></a>00754  
<a name="l00755"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a94f6214aa3793fab6783627d594248b7">00755</a>  <a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* <a class="code" href="class_gorilla_1_1_layer_container.html#a94f6214aa3793fab6783627d594248b7">LayerContainer::createLayer</a>(Ogre::uint index)
<a name="l00756"></a>00756  {
<a name="l00757"></a>00757   <a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* layer = OGRE_NEW <a class="code" href="class_gorilla_1_1_layer.html">Layer</a>(index, <span class="keyword">this</span>);
<a name="l00758"></a>00758   <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.push_back(layer);
<a name="l00759"></a>00759   
<a name="l00760"></a>00760   std::map&lt;Ogre::uint, IndexData*&gt;::iterator index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( layer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a63f2bb87ada4a396a5a3b9553da52769">getIndex</a>() );
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (index_data == <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end())
<a name="l00762"></a>00762   {
<a name="l00763"></a>00763    <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>[layer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a63f2bb87ada4a396a5a3b9553da52769">getIndex</a>()] = OGRE_NEW <a class="code" href="struct_gorilla_1_1_layer_container_1_1_index_data.html">IndexData</a>();
<a name="l00764"></a>00764    index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( layer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a63f2bb87ada4a396a5a3b9553da52769">getIndex</a>() );
<a name="l00765"></a>00765   }
<a name="l00766"></a>00766   
<a name="l00767"></a>00767   (*index_data).second-&gt;mLayers.push_back( layer );
<a name="l00768"></a>00768   (*index_data).second-&gt;mRedrawNeeded = <span class="keyword">true</span>;
<a name="l00769"></a>00769   
<a name="l00770"></a>00770   <a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a> = <span class="keyword">true</span>;
<a name="l00771"></a>00771   
<a name="l00772"></a>00772   <span class="keywordflow">return</span> layer;
<a name="l00773"></a>00773  }
<a name="l00774"></a>00774   <span class="comment"></span>
<a name="l00775"></a>00775 <span class="comment"> /*! function. destroyLayer</span>
<a name="l00776"></a>00776 <span class="comment">     desc.</span>
<a name="l00777"></a>00777 <span class="comment">         Destroy a layer and it&#39;s contents.</span>
<a name="l00778"></a>00778 <span class="comment"> */</span>
<a name="l00779"></a><a class="code" href="class_gorilla_1_1_layer_container.html#aea67cde374f6c9f3fe33d9ddac007780">00779</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#aea67cde374f6c9f3fe33d9ddac007780">LayerContainer::destroy</a>(<a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* layer)
<a name="l00780"></a>00780  {
<a name="l00781"></a>00781   <span class="keywordflow">if</span> (layer == 0)
<a name="l00782"></a>00782    <span class="keywordflow">return</span>;
<a name="l00783"></a>00783   
<a name="l00784"></a>00784   std::map&lt;Ogre::uint, IndexData*&gt;::iterator index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( layer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a63f2bb87ada4a396a5a3b9553da52769">getIndex</a>() );
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="comment">// Remove layer from index, and delete index if index is empty.</span>
<a name="l00787"></a>00787   <span class="keywordflow">if</span> (index_data != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end())
<a name="l00788"></a>00788   {
<a name="l00789"></a>00789    <a class="code" href="struct_gorilla_1_1_layer_container_1_1_index_data.html">IndexData</a>* indexData = (*index_data).second;
<a name="l00790"></a>00790    indexData-&gt;mLayers.erase(std::find(indexData-&gt;mLayers.begin(), indexData-&gt;mLayers.end(), layer));
<a name="l00791"></a>00791    indexData-&gt;mRedrawNeeded = <span class="keyword">true</span>;
<a name="l00792"></a>00792    <a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a> = <span class="keyword">true</span>;
<a name="l00793"></a>00793    <span class="keywordflow">if</span> (indexData-&gt;mLayers.size() == 0)
<a name="l00794"></a>00794    {
<a name="l00795"></a>00795     <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.erase(index_data);
<a name="l00796"></a>00796     OGRE_DELETE indexData;
<a name="l00797"></a>00797    }
<a name="l00798"></a>00798   }
<a name="l00799"></a>00799   
<a name="l00800"></a>00800   <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.erase(std::find(<a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.begin(), <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.end(), layer));
<a name="l00801"></a>00801   OGRE_DELETE layer;
<a name="l00802"></a>00802  }
<a name="l00803"></a>00803 
<a name="l00804"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a27a32957069c30c395658960a2c70ee8">00804</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#a27a32957069c30c395658960a2c70ee8">LayerContainer::_createVertexBuffer</a>(<span class="keywordtype">size_t</span> initialSize = 32)
<a name="l00805"></a>00805  {
<a name="l00806"></a>00806   <a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a> = initialSize * 6;
<a name="l00807"></a>00807   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData = OGRE_NEW Ogre::VertexData;
<a name="l00808"></a>00808   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexStart = 0;
<a name="l00809"></a>00809   
<a name="l00810"></a>00810   Ogre::VertexDeclaration* vertexDecl = <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexDeclaration;
<a name="l00811"></a>00811   <span class="keywordtype">size_t</span> offset = 0;
<a name="l00812"></a>00812   
<a name="l00813"></a>00813   <span class="comment">// Position.</span>
<a name="l00814"></a>00814   vertexDecl-&gt;addElement(0,0, Ogre::VET_FLOAT3, Ogre::VES_POSITION);
<a name="l00815"></a>00815   offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT3);
<a name="l00816"></a>00816   
<a name="l00817"></a>00817   <span class="comment">// Colour</span>
<a name="l00818"></a>00818   vertexDecl-&gt;addElement(0, offset, Ogre::VET_FLOAT4, Ogre::VES_DIFFUSE);
<a name="l00819"></a>00819   offset += Ogre::VertexElement::getTypeSize(Ogre::VET_FLOAT4);
<a name="l00820"></a>00820   
<a name="l00821"></a>00821   <span class="comment">// Texture Coordinates</span>
<a name="l00822"></a>00822   vertexDecl-&gt;addElement(0, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES);
<a name="l00823"></a>00823   
<a name="l00824"></a>00824   <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a> = Ogre::HardwareBufferManager::getSingletonPtr()
<a name="l00825"></a>00825      -&gt;createVertexBuffer(
<a name="l00826"></a>00826          vertexDecl-&gt;getVertexSize(0),
<a name="l00827"></a>00827          <a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a>,
<a name="l00828"></a>00828          Ogre::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,
<a name="l00829"></a>00829          false
<a name="l00830"></a>00830      );
<a name="l00831"></a>00831   
<a name="l00832"></a>00832   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexBufferBinding-&gt;setBinding(0, <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a>);
<a name="l00833"></a>00833   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;operationType = Ogre::RenderOperation::OT_TRIANGLE_LIST;
<a name="l00834"></a>00834   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;useIndexes = <span class="keyword">false</span>;
<a name="l00835"></a>00835  }
<a name="l00836"></a>00836  
<a name="l00837"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a00c30924b3036d71fcf12b3ebaa4bee8">00837</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#a00c30924b3036d71fcf12b3ebaa4bee8">LayerContainer::_destroyVertexBuffer</a>()
<a name="l00838"></a>00838  {
<a name="l00839"></a>00839   OGRE_DELETE <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData;
<a name="l00840"></a>00840   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData = 0;
<a name="l00841"></a>00841   <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a>.setNull();
<a name="l00842"></a>00842   <a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a> = 0;
<a name="l00843"></a>00843  }
<a name="l00844"></a>00844  
<a name="l00845"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a6a49ad8bf2e41c0534e3aaccb3c38d08">00845</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#a6a49ad8bf2e41c0534e3aaccb3c38d08">LayerContainer::_resizeVertexBuffer</a>(<span class="keywordtype">size_t</span> requestedSize)
<a name="l00846"></a>00846  {
<a name="l00847"></a>00847   
<a name="l00848"></a>00848   <span class="keywordflow">if</span> (<a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a> == 0)
<a name="l00849"></a>00849    <a class="code" href="class_gorilla_1_1_layer_container.html#a27a32957069c30c395658960a2c70ee8">_createVertexBuffer</a>();
<a name="l00850"></a>00850   
<a name="l00851"></a>00851   <span class="keywordflow">if</span> (requestedSize &gt; <a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a>)
<a name="l00852"></a>00852   {
<a name="l00853"></a>00853    <span class="keywordtype">size_t</span> newVertexBufferSize = 1;
<a name="l00854"></a>00854    
<a name="l00855"></a>00855    <span class="keywordflow">while</span>(newVertexBufferSize &lt; requestedSize)
<a name="l00856"></a>00856     newVertexBufferSize &lt;&lt;= 1;
<a name="l00857"></a>00857    
<a name="l00858"></a>00858    <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a> = Ogre::HardwareBufferManager::getSingletonPtr()-&gt;createVertexBuffer(
<a name="l00859"></a>00859      <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexDeclaration-&gt;getVertexSize(0),
<a name="l00860"></a>00860      newVertexBufferSize,
<a name="l00861"></a>00861      Ogre::HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE,
<a name="l00862"></a>00862      false
<a name="l00863"></a>00863    );
<a name="l00864"></a>00864    <a class="code" href="class_gorilla_1_1_layer_container.html#a876102c71726fddf7d1825cf6bb5be06" title="mVertexBufferSize -- How much the VertexBuffer can hold.">mVertexBufferSize</a> = newVertexBufferSize;
<a name="l00865"></a>00865    <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexStart = 0;
<a name="l00866"></a>00866    <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexBufferBinding-&gt;setBinding(0, <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a>);
<a name="l00867"></a>00867   }
<a name="l00868"></a>00868   
<a name="l00869"></a>00869  }
<a name="l00870"></a>00870  
<a name="l00871"></a>00871  <span class="keywordtype">void</span> LayerContainer::_recalculateIndexes()
<a name="l00872"></a>00872  {
<a name="l00873"></a>00873   
<a name="l00874"></a>00874   std::map&lt;Ogre::uint, IndexData*&gt;::iterator index_data;
<a name="l00875"></a>00875   
<a name="l00876"></a>00876   <span class="comment">// Clear all index data.</span>
<a name="l00877"></a>00877   <span class="keywordflow">for</span>(std::map&lt; Ogre::uint, IndexData* &gt;::iterator index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); index_data != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end(); index_data++)
<a name="l00878"></a>00878   {
<a name="l00879"></a>00879    (*index_data).second-&gt;mVertices.remove_all();
<a name="l00880"></a>00880    (*index_data).second-&gt;mLayers.clear();
<a name="l00881"></a>00881    (*index_data).second-&gt;mRedrawNeeded = <span class="keyword">false</span>;
<a name="l00882"></a>00882   }
<a name="l00883"></a>00883   
<a name="l00884"></a>00884   <span class="comment">// Loop through layers, and add them to IndexData</span>
<a name="l00885"></a>00885   <span class="keywordflow">for</span>(std::vector&lt;Layer*&gt;::iterator layer = <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.begin(); layer != <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.end(); layer++)
<a name="l00886"></a>00886   {
<a name="l00887"></a>00887    index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( (*layer)-&gt;getIndex() );
<a name="l00888"></a>00888    <span class="keywordflow">if</span> (index_data == <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end())
<a name="l00889"></a>00889    {
<a name="l00890"></a>00890     <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>[(*layer)-&gt;getIndex()] = OGRE_NEW IndexData();
<a name="l00891"></a>00891     index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( (*layer)-&gt;getIndex() );
<a name="l00892"></a>00892    }
<a name="l00893"></a>00893    
<a name="l00894"></a>00894    (*index_data).second-&gt;mLayers.push_back( (*layer) );
<a name="l00895"></a>00895   }
<a name="l00896"></a>00896   
<a name="l00897"></a>00897   <span class="comment">// Prune any index data that is not.</span>
<a name="l00898"></a>00898   <span class="keywordtype">bool</span> deleted = <span class="keyword">false</span>;
<a name="l00899"></a>00899   
<a name="l00900"></a>00900   <span class="keywordflow">while</span>(0xDEADBEEF)
<a name="l00901"></a>00901   {
<a name="l00902"></a>00902    deleted = <span class="keyword">false</span>;
<a name="l00903"></a>00903    <span class="keywordflow">for</span>(std::map&lt; Ogre::uint, IndexData* &gt;::iterator index_data = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); index_data != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end(); index_data++)
<a name="l00904"></a>00904    {
<a name="l00905"></a>00905     <span class="keywordflow">if</span> (  (*index_data).second-&gt;mLayers.size() == 0)
<a name="l00906"></a>00906     {
<a name="l00907"></a>00907      OGRE_DELETE (*index_data).second;
<a name="l00908"></a>00908      <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.erase(index_data);
<a name="l00909"></a>00909      deleted = <span class="keyword">true</span>;
<a name="l00910"></a>00910      <span class="keywordflow">break</span>;
<a name="l00911"></a>00911     }
<a name="l00912"></a>00912    }
<a name="l00913"></a>00913    
<a name="l00914"></a>00914    <span class="keywordflow">if</span> (!deleted)
<a name="l00915"></a>00915     <span class="keywordflow">break</span>;
<a name="l00916"></a>00916    
<a name="l00917"></a>00917   }
<a name="l00918"></a>00918   
<a name="l00919"></a>00919   <a class="code" href="class_gorilla_1_1_layer_container.html#ad92de153fa002d7e833a04141e709f95" title="mRedrawAll -- All indexes need to be redrawn regardless of state.">mIndexRedrawAll</a> = <span class="keyword">true</span>;
<a name="l00920"></a>00920   
<a name="l00921"></a>00921  }
<a name="l00922"></a>00922  
<a name="l00923"></a><a class="code" href="class_gorilla_1_1_layer_container.html#aea49171d443f077f38a480c76aa046dd">00923</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#aea49171d443f077f38a480c76aa046dd">LayerContainer::_redrawIndex</a>(Ogre::uint index, <span class="keywordtype">bool</span> force)
<a name="l00924"></a>00924  {
<a name="l00925"></a>00925   
<a name="l00926"></a>00926   std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( index );
<a name="l00927"></a>00927   <span class="keywordflow">if</span> (it == <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end())
<a name="l00928"></a>00928    <span class="keywordflow">return</span>;
<a name="l00929"></a>00929   
<a name="l00930"></a>00930   <a class="code" href="struct_gorilla_1_1_layer_container_1_1_index_data.html">IndexData</a>* indexData = (*it).second;
<a name="l00931"></a>00931   
<a name="l00932"></a>00932   indexData-&gt;mVertices.remove_all();
<a name="l00933"></a>00933   indexData-&gt;mRedrawNeeded = <span class="keyword">false</span>;
<a name="l00934"></a>00934   
<a name="l00935"></a>00935   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; indexData-&gt;mLayers.size();i++)
<a name="l00936"></a>00936   {
<a name="l00937"></a>00937    <span class="keywordflow">if</span> (indexData-&gt;mLayers[i]-&gt;mVisible)
<a name="l00938"></a>00938     indexData-&gt;mLayers[i]-&gt;_render( indexData-&gt;mVertices, force );
<a name="l00939"></a>00939   }
<a name="l00940"></a>00940   
<a name="l00941"></a>00941  }
<a name="l00942"></a>00942  
<a name="l00943"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a7e7ad01c35bca4e64212a54cd2195162">00943</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#a7e7ad01c35bca4e64212a54cd2195162">LayerContainer::_requestIndexRedraw</a>(Ogre::uint index)
<a name="l00944"></a>00944  {
<a name="l00945"></a>00945   std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.find( index );
<a name="l00946"></a>00946   <span class="keywordflow">if</span> (it == <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end())
<a name="l00947"></a>00947    <span class="keywordflow">return</span>;
<a name="l00948"></a>00948    
<a name="l00949"></a>00949   (*it).second-&gt;mRedrawNeeded = <span class="keyword">true</span>;
<a name="l00950"></a>00950   <a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a> = <span class="keyword">true</span>;
<a name="l00951"></a>00951  }
<a name="l00952"></a>00952  
<a name="l00953"></a><a class="code" href="class_gorilla_1_1_layer_container.html#aaa13be0c88052b14a9fd949ff53ef538">00953</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#aaa13be0c88052b14a9fd949ff53ef538">LayerContainer::_redrawAllIndexes</a>(<span class="keywordtype">bool</span> force)
<a name="l00954"></a>00954  {
<a name="l00955"></a>00955   <a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a> = <span class="keyword">false</span>;
<a name="l00956"></a>00956   <span class="keywordflow">for</span>(std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); it != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end();it++)
<a name="l00957"></a>00957   {
<a name="l00958"></a>00958    <a class="code" href="struct_gorilla_1_1_layer_container_1_1_index_data.html">IndexData</a>* indexData = (*it).second;
<a name="l00959"></a>00959    <span class="keywordflow">if</span> (indexData-&gt;mRedrawNeeded || force)
<a name="l00960"></a>00960    {
<a name="l00961"></a>00961     <span class="comment">//std::cout &lt;&lt; &quot;+++ Drawing Index: &quot; &lt;&lt; (*it).first;</span>
<a name="l00962"></a>00962     indexData-&gt;mVertices.remove_all();
<a name="l00963"></a>00963     indexData-&gt;mRedrawNeeded = <span class="keyword">false</span>;
<a name="l00964"></a>00964     
<a name="l00965"></a>00965     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; indexData-&gt;mLayers.size();i++)
<a name="l00966"></a>00966     {
<a name="l00967"></a>00967      <span class="keywordflow">if</span> (indexData-&gt;mLayers[i]-&gt;mVisible)
<a name="l00968"></a>00968       indexData-&gt;mLayers[i]-&gt;_render( indexData-&gt;mVertices, force );
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970    }
<a name="l00971"></a>00971    
<a name="l00972"></a>00972   }
<a name="l00973"></a>00973  }
<a name="l00974"></a>00974  
<a name="l00975"></a><a class="code" href="class_gorilla_1_1_layer_container.html#a6ed01a434a94b471fb96990cd5727a4f">00975</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer_container.html#a6ed01a434a94b471fb96990cd5727a4f">LayerContainer::_renderVertices</a>(<span class="keywordtype">bool</span> force)
<a name="l00976"></a>00976  {
<a name="l00977"></a>00977   
<a name="l00978"></a>00978   <span class="keywordflow">if</span> (<a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a> == <span class="keyword">false</span>)
<a name="l00979"></a>00979    <span class="keywordflow">if</span> (!force)
<a name="l00980"></a>00980     <span class="keywordflow">return</span>;
<a name="l00981"></a>00981   
<a name="l00982"></a>00982   <a class="code" href="class_gorilla_1_1_layer_container.html#aaa13be0c88052b14a9fd949ff53ef538">_redrawAllIndexes</a>(force);
<a name="l00983"></a>00983   
<a name="l00984"></a>00984   <span class="keywordtype">size_t</span> knownVertexCount = 0;
<a name="l00985"></a>00985   
<a name="l00986"></a>00986   <span class="keywordflow">for</span>(std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); it != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end();it++)
<a name="l00987"></a>00987    knownVertexCount += (*it).second-&gt;mVertices.size();
<a name="l00988"></a>00988   
<a name="l00989"></a>00989   <a class="code" href="class_gorilla_1_1_layer_container.html#a6a49ad8bf2e41c0534e3aaccb3c38d08">_resizeVertexBuffer</a>(knownVertexCount);
<a name="l00990"></a>00990   <span class="comment">//std::cout &lt;&lt; &quot;+++ Known Vertex Count is: &quot; &lt;&lt; knownVertexCount &lt;&lt; &quot;\n&quot;;</span>
<a name="l00991"></a>00991   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a>* writeIterator = (<a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a>*) <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a>-&gt;lock(Ogre::HardwareBuffer::HBL_DISCARD);
<a name="l00992"></a>00992   
<a name="l00993"></a>00993   <span class="keywordtype">size_t</span> i = 0;
<a name="l00994"></a>00994   <a class="code" href="struct_gorilla_1_1_layer_container_1_1_index_data.html">IndexData</a>* indexData = 0;
<a name="l00995"></a>00995   <span class="keywordflow">for</span>(std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); it != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end();it++)
<a name="l00996"></a>00996   {
<a name="l00997"></a>00997    indexData = (*it).second;
<a name="l00998"></a>00998    <span class="keywordflow">for</span> (i=0;i &lt; indexData-&gt;mVertices.size();i++)
<a name="l00999"></a>00999    {
<a name="l01000"></a>01000     *writeIterator++ = indexData-&gt;mVertices[i];
<a name="l01001"></a>01001    }
<a name="l01002"></a>01002   }
<a name="l01003"></a>01003   
<a name="l01004"></a>01004   <a class="code" href="class_gorilla_1_1_layer_container.html#a23ef28a725307c782b91ec4cba1a4961" title="mVertexBuffer -- Compiled layers of all indexes go into here for rendering directly...">mVertexBuffer</a>-&gt;unlock();
<a name="l01005"></a>01005   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a>-&gt;vertexData-&gt;vertexCount = knownVertexCount;
<a name="l01006"></a>01006  }
<a name="l01007"></a>01007  
<a name="l01008"></a>01008  
<a name="l01009"></a><a class="code" href="class_gorilla_1_1_screen.html#a5d59498e523180545a81929ed68a2593">01009</a>  <a class="code" href="class_gorilla_1_1_screen.html#a5d59498e523180545a81929ed68a2593">Screen::Screen</a>(Ogre::Viewport* viewport, <a class="code" href="class_gorilla_1_1_texture_atlas.html">TextureAtlas</a>* atlas)
<a name="l01010"></a>01010  : <a class="code" href="class_gorilla_1_1_layer_container.html">LayerContainer</a>(atlas), mViewport(viewport), mIsVisible(true), mScale(1,1,1), mCanRender(false)
<a name="l01011"></a>01011  {
<a name="l01012"></a>01012   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a> = &amp;mRenderOp;
<a name="l01013"></a>01013   mSceneMgr = mViewport-&gt;getCamera()-&gt;getSceneManager();
<a name="l01014"></a>01014   
<a name="l01015"></a>01015   mRenderSystem = Ogre::Root::getSingletonPtr()-&gt;getRenderSystem();
<a name="l01016"></a>01016   
<a name="l01017"></a>01017   mWidth = mViewport-&gt;getActualWidth();
<a name="l01018"></a>01018   mHeight = mViewport-&gt;getActualHeight();
<a name="l01019"></a>01019 <span class="preprocessor">#if OGRE_NO_VIEWPORT_ORIENTATIONMODE == 0</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span>  mOrientation = mViewport-&gt;getOrientationMode();
<a name="l01021"></a>01021 <span class="preprocessor">#else</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>  mOrientation = Ogre::OR_DEGREE_0;
<a name="l01023"></a>01023   mOrientationChanged = <span class="keyword">false</span>;
<a name="l01024"></a>01024 <span class="preprocessor">#endif</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>  
<a name="l01026"></a>01026   mInvWidth = 1.0f / mWidth;
<a name="l01027"></a>01027   mInvHeight = 1.0f / mHeight;
<a name="l01028"></a>01028   
<a name="l01029"></a>01029   mVertexTransform.makeTransform(Ogre::Vector3::ZERO, mScale, Ogre::Quaternion(1,0,0,0));
<a name="l01030"></a>01030   
<a name="l01031"></a>01031   mSceneMgr-&gt;addRenderQueueListener(<span class="keyword">this</span>);
<a name="l01032"></a>01032   <a class="code" href="class_gorilla_1_1_layer_container.html#a27a32957069c30c395658960a2c70ee8">_createVertexBuffer</a>();
<a name="l01033"></a>01033  }
<a name="l01034"></a>01034 
<a name="l01035"></a><a class="code" href="class_gorilla_1_1_screen.html#a75f2e03152cdd1bd21c6949655e09671">01035</a>  <a class="code" href="class_gorilla_1_1_screen.html#a75f2e03152cdd1bd21c6949655e09671">Screen::~Screen</a>()
<a name="l01036"></a>01036  {
<a name="l01037"></a>01037   mSceneMgr-&gt;removeRenderQueueListener(<span class="keyword">this</span>);
<a name="l01038"></a>01038  }
<a name="l01039"></a>01039  
<a name="l01040"></a>01040  
<a name="l01041"></a>01041  <span class="keywordtype">void</span> Screen::renderQueueEnded(Ogre::uint8 queueGroupId, <span class="keyword">const</span> Ogre::String&amp; invocation, <span class="keywordtype">bool</span>&amp; repeatThisInvocation)
<a name="l01042"></a>01042  {
<a name="l01043"></a>01043   <span class="keywordflow">if</span> (mRenderSystem-&gt;_getViewport() != mViewport || queueGroupId != SCREEN_RENDERQUEUE)
<a name="l01044"></a>01044    <span class="keywordflow">return</span>;
<a name="l01045"></a>01045   <span class="keywordflow">if</span> (mIsVisible &amp;&amp; <a class="code" href="class_gorilla_1_1_layer_container.html#aa10de3b9c00b42640d196c3eae1648c0" title="mLayers -- Master copy of all layers of this Target.">mLayers</a>.size())
<a name="l01046"></a>01046    <a class="code" href="class_gorilla_1_1_screen.html#a2a0a113f331788bff7065902f994748c">renderOnce</a>();
<a name="l01047"></a>01047  }
<a name="l01048"></a>01048  
<a name="l01049"></a>01049  <span class="keywordtype">void</span> Screen::_prepareRenderSystem()
<a name="l01050"></a>01050  {
<a name="l01051"></a>01051   mRenderSystem-&gt;_setWorldMatrix( Ogre::Matrix4::IDENTITY );
<a name="l01052"></a>01052   mRenderSystem-&gt;_setProjectionMatrix( Ogre::Matrix4::IDENTITY );
<a name="l01053"></a>01053   mRenderSystem-&gt;_setViewMatrix( Ogre::Matrix4::IDENTITY );
<a name="l01054"></a>01054   mSceneMgr-&gt;_setPass(<a class="code" href="class_gorilla_1_1_layer_container.html#a64225a839f60594228a3f34a5523ca38" title="Atlas assigned to this LayerContainer.">mAtlas</a>-&gt;get2DPass());
<a name="l01055"></a>01055  }
<a name="l01056"></a>01056 
<a name="l01057"></a><a class="code" href="class_gorilla_1_1_screen.html#a2a0a113f331788bff7065902f994748c">01057</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_screen.html#a2a0a113f331788bff7065902f994748c">Screen::renderOnce</a>()
<a name="l01058"></a>01058  {
<a name="l01059"></a>01059   <span class="keywordtype">bool</span> force = <span class="keyword">false</span>;
<a name="l01060"></a>01060   <span class="comment">// force == true if viewport size changed.</span>
<a name="l01061"></a>01061   <span class="keywordflow">if</span> (mWidth != mViewport-&gt;getActualWidth() || mHeight != mViewport-&gt;getActualHeight() 
<a name="l01062"></a>01062 <span class="preprocessor">#if OGRE_NO_VIEWPORT_ORIENTATIONMODE == 0</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span>    || mOrientation != mViewport-&gt;getOrientationMode()
<a name="l01064"></a>01064 <span class="preprocessor">#else</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>    || mOrientationChanged
<a name="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span>    )
<a name="l01068"></a>01068   {
<a name="l01069"></a>01069    mWidth = mViewport-&gt;getActualWidth();
<a name="l01070"></a>01070    mHeight = mViewport-&gt;getActualHeight();
<a name="l01071"></a>01071    
<a name="l01072"></a>01072    mInvWidth = 1.0f / mWidth;
<a name="l01073"></a>01073    mInvHeight = 1.0f / mHeight;
<a name="l01074"></a>01074    
<a name="l01075"></a>01075 <span class="preprocessor">#if OGRE_NO_VIEWPORT_ORIENTATIONMODE == 0</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span>   mOrientation = mViewport-&gt;getOrientationMode();
<a name="l01077"></a>01077 <span class="preprocessor">#else</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (mOrientation == Ogre::OR_DEGREE_90 || mOrientation == Ogre::OR_DEGREE_270)
<a name="l01079"></a>01079    {
<a name="l01080"></a>01080     std::swap(mWidth, mHeight);
<a name="l01081"></a>01081     std::swap(mInvWidth, mInvHeight);
<a name="l01082"></a>01082    }
<a name="l01083"></a>01083    mOrientationChanged = <span class="keyword">false</span>;
<a name="l01084"></a>01084 <span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>   
<a name="l01086"></a>01086    <span class="keywordflow">if</span> (mOrientation == Ogre::OR_DEGREE_90)
<a name="l01087"></a>01087     mVertexTransform.makeTransform(Ogre::Vector3::ZERO, mScale, Ogre::Quaternion(Ogre::Degree(90), Ogre::Vector3::UNIT_Z));
<a name="l01088"></a>01088    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mOrientation == Ogre::OR_DEGREE_180)
<a name="l01089"></a>01089      mVertexTransform.makeTransform(Ogre::Vector3::ZERO, mScale, Ogre::Quaternion(Ogre::Degree(180), Ogre::Vector3::UNIT_Z));
<a name="l01090"></a>01090    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mOrientation == Ogre::OR_DEGREE_270)
<a name="l01091"></a>01091      mVertexTransform.makeTransform(Ogre::Vector3::ZERO, mScale, Ogre::Quaternion(Ogre::Degree(270), Ogre::Vector3::UNIT_Z));
<a name="l01092"></a>01092    <span class="keywordflow">else</span>
<a name="l01093"></a>01093      mVertexTransform.makeTransform(Ogre::Vector3::ZERO, mScale, Ogre::Quaternion(1,0,0,0));
<a name="l01094"></a>01094 
<a name="l01095"></a>01095    
<a name="l01096"></a>01096    force = <span class="keyword">true</span>;
<a name="l01097"></a>01097   }
<a name="l01098"></a>01098   
<a name="l01099"></a>01099   <a class="code" href="class_gorilla_1_1_layer_container.html#a6ed01a434a94b471fb96990cd5727a4f">_renderVertices</a>(force);
<a name="l01100"></a>01100   <span class="keywordflow">if</span> (mRenderOp.vertexData-&gt;vertexCount)
<a name="l01101"></a>01101   {
<a name="l01102"></a>01102    _prepareRenderSystem();
<a name="l01103"></a>01103    mRenderSystem-&gt;_render(mRenderOp);
<a name="l01104"></a>01104   }
<a name="l01105"></a>01105  }
<a name="l01106"></a>01106  
<a name="l01107"></a>01107  <span class="keywordtype">void</span>  Screen::_transform(<a class="code" href="class_gorilla_1_1buffer.html">buffer&lt;Vertex&gt;</a>&amp; vertices, <span class="keywordtype">size_t</span> begin, <span class="keywordtype">size_t</span> end) 
<a name="l01108"></a>01108  {
<a name="l01109"></a>01109   
<a name="l01110"></a>01110   
<a name="l01111"></a>01111   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = begin; i &lt; end; i++)
<a name="l01112"></a>01112   {
<a name="l01113"></a>01113    vertices[i].position.x = ((vertices[i].position.x) * mInvWidth) * 2 - 1;
<a name="l01114"></a>01114    vertices[i].position.y = ((vertices[i].position.y) * mInvHeight) * -2 + 1;
<a name="l01115"></a>01115   }
<a name="l01116"></a>01116   
<a name="l01117"></a>01117   <span class="keywordflow">if</span> (mVertexTransform != Ogre::Matrix4::IDENTITY)
<a name="l01118"></a>01118   {
<a name="l01119"></a>01119    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = begin; i &lt; end; i++)
<a name="l01120"></a>01120      vertices[i].position = mVertexTransform * vertices[i].position;
<a name="l01121"></a>01121   }
<a name="l01122"></a>01122   
<a name="l01123"></a>01123  }
<a name="l01124"></a>01124  
<a name="l01125"></a>01125  
<a name="l01126"></a>01126  
<a name="l01127"></a>01127  ScreenRenderable::ScreenRenderable(<span class="keyword">const</span> Ogre::Vector2&amp; maxSize, TextureAtlas* atlas)
<a name="l01128"></a>01128  : LayerContainer(atlas), mMaxSize(maxSize)
<a name="l01129"></a>01129  {
<a name="l01130"></a>01130   <a class="code" href="class_gorilla_1_1_layer_container.html#a61057b81d5c607d75914922f1790c46b" title="mRenderOpPtr -- Pointer to the RenderOperation (Not owned by LayerContainer)">mRenderOpPtr</a> = &amp;mRenderOp;
<a name="l01131"></a>01131   
<a name="l01132"></a>01132   mBox.setInfinite();
<a name="l01133"></a>01133   setMaterial(<a class="code" href="class_gorilla_1_1_layer_container.html#a64225a839f60594228a3f34a5523ca38" title="Atlas assigned to this LayerContainer.">mAtlas</a>-&gt;get3DMaterialName());
<a name="l01134"></a>01134   
<a name="l01135"></a>01135   <a class="code" href="class_gorilla_1_1_layer_container.html#a27a32957069c30c395658960a2c70ee8">_createVertexBuffer</a>();
<a name="l01136"></a>01136  }
<a name="l01137"></a>01137  
<a name="l01138"></a>01138  ScreenRenderable::~ScreenRenderable()
<a name="l01139"></a>01139  {
<a name="l01140"></a>01140  }
<a name="l01141"></a>01141  
<a name="l01142"></a>01142  <span class="keywordtype">void</span> ScreenRenderable::frameStarted()
<a name="l01143"></a>01143  {
<a name="l01144"></a>01144   <a class="code" href="class_gorilla_1_1_screen_renderable.html#ac826d293b312494d74de842f491ca73b">renderOnce</a>();
<a name="l01145"></a>01145  }
<a name="l01146"></a>01146  
<a name="l01147"></a><a class="code" href="class_gorilla_1_1_screen_renderable.html#ac826d293b312494d74de842f491ca73b">01147</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_screen_renderable.html#ac826d293b312494d74de842f491ca73b">ScreenRenderable::renderOnce</a>()
<a name="l01148"></a>01148  {
<a name="l01149"></a>01149   <span class="keywordflow">if</span> (<a class="code" href="class_gorilla_1_1_layer_container.html#aacfb8bb32bd291929d14628e3fd0a919" title="mIndexRedrawNeeded -- An index (not sure what) needs to be redrawn.">mIndexRedrawNeeded</a>)
<a name="l01150"></a>01150   {
<a name="l01151"></a>01151    <a class="code" href="class_gorilla_1_1_layer_container.html#a6ed01a434a94b471fb96990cd5727a4f">_renderVertices</a>(<span class="keyword">false</span>);
<a name="l01152"></a>01152    calculateBoundingBox();
<a name="l01153"></a>01153   }
<a name="l01154"></a>01154  }
<a name="l01155"></a>01155  
<a name="l01156"></a>01156  <span class="keywordtype">void</span> ScreenRenderable::calculateBoundingBox()
<a name="l01157"></a>01157  {
<a name="l01158"></a>01158   IndexData* indexData = 0;
<a name="l01159"></a>01159   mBox.setExtents(0,0,0,0,0,0);
<a name="l01160"></a>01160   <span class="keywordtype">size_t</span> i = 0;
<a name="l01161"></a>01161   <span class="keywordflow">for</span>(std::map&lt;Ogre::uint, IndexData*&gt;::iterator it = <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.begin(); it != <a class="code" href="class_gorilla_1_1_layer_container.html#a78332d894c41c1b064dc9de706d8c115" title="mIndexes -- Copies pointers to Layers arranged their index.">mIndexData</a>.end();it++)
<a name="l01162"></a>01162   {
<a name="l01163"></a>01163    indexData = (*it).second;
<a name="l01164"></a>01164    <span class="keywordflow">for</span> (i=0;i &lt; indexData-&gt;mVertices.size();i++)
<a name="l01165"></a>01165    {
<a name="l01166"></a>01166     mBox.merge( indexData-&gt;mVertices[i].position );
<a name="l01167"></a>01167    }
<a name="l01168"></a>01168   }
<a name="l01169"></a>01169   <span class="keywordflow">if</span> (mBox.isNull() == <span class="keyword">false</span>)
<a name="l01170"></a>01170   {
<a name="l01171"></a>01171    mBox.merge(Ogre::Vector3(0,0,-0.25f));
<a name="l01172"></a>01172    mBox.merge(Ogre::Vector3(0,0, 0.25f));
<a name="l01173"></a>01173    
<a name="l01174"></a>01174   }
<a name="l01175"></a>01175   
<a name="l01176"></a>01176   Ogre::SceneNode* node = getParentSceneNode();
<a name="l01177"></a>01177   <span class="keywordflow">if</span> (node)
<a name="l01178"></a>01178    node-&gt;_updateBounds();
<a name="l01179"></a>01179  
<a name="l01180"></a>01180  }
<a name="l01181"></a>01181  
<a name="l01182"></a>01182  <span class="keywordtype">void</span> ScreenRenderable::_transform(buffer&lt;Vertex&gt;&amp; vertices, <span class="keywordtype">size_t</span> begin, <span class="keywordtype">size_t</span> end)
<a name="l01183"></a>01183  {
<a name="l01184"></a>01184   Ogre::Vector2 halfSize = mMaxSize * 0.5;
<a name="l01185"></a>01185   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = begin; i &lt; end; i++)
<a name="l01186"></a>01186   {
<a name="l01187"></a>01187    vertices[i].position.x = (vertices[i].position.x * 0.01f) - halfSize.x;
<a name="l01188"></a>01188    vertices[i].position.y = (vertices[i].position.y * -0.01f) + halfSize.y;
<a name="l01189"></a>01189   }
<a name="l01190"></a>01190  }
<a name="l01191"></a>01191  
<a name="l01192"></a>01192  
<a name="l01193"></a>01193  Layer::Layer(Ogre::uint index, LayerContainer* parent)
<a name="l01194"></a>01194  : mIndex(index), mParent(parent), mVisible(true), mAlphaModifier(1.0f)
<a name="l01195"></a>01195  {
<a name="l01196"></a>01196  }
<a name="l01197"></a>01197  
<a name="l01198"></a>01198  Layer::~Layer()
<a name="l01199"></a>01199  {
<a name="l01200"></a>01200   <a class="code" href="class_gorilla_1_1_layer.html#ac65d00ab01ec42332bdbc6dad2176859">destroyAllRectangles</a>();
<a name="l01201"></a>01201   <a class="code" href="class_gorilla_1_1_layer.html#a5d639003c496633bf8ca338a0cd8b930">destroyAllPolygons</a>();
<a name="l01202"></a>01202   <a class="code" href="class_gorilla_1_1_layer.html#af51fb3b28c01f52959712489920684de">destroyAllLineLists</a>();
<a name="l01203"></a>01203   <a class="code" href="class_gorilla_1_1_layer.html#a7053cc9dbc7a2cff1fc2e911b3f19d36">destroyAllQuadLists</a>();
<a name="l01204"></a>01204   <a class="code" href="class_gorilla_1_1_layer.html#a84dfd109b772d00a4e5e39544f3e8612">destroyAllCaptions</a>();
<a name="l01205"></a>01205   <a class="code" href="class_gorilla_1_1_layer.html#ad956895440c5351dc635901cce57e318">destroyAllMarkupTexts</a>();
<a name="l01206"></a>01206  }
<a name="l01207"></a>01207  
<a name="l01208"></a><a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">01208</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">Layer::_markDirty</a>()
<a name="l01209"></a>01209  {
<a name="l01210"></a>01210   mParent-&gt;<a class="code" href="class_gorilla_1_1_layer_container.html#a7e7ad01c35bca4e64212a54cd2195162">_requestIndexRedraw</a>(mIndex);
<a name="l01211"></a>01211  }
<a name="l01212"></a>01212  
<a name="l01213"></a><a class="code" href="class_gorilla_1_1_layer.html#ae92bfd3aca9f157cacc61df915dc71ce">01213</a>  <a class="code" href="class_gorilla_1_1_rectangle.html">Rectangle</a>* <a class="code" href="class_gorilla_1_1_layer.html#ae92bfd3aca9f157cacc61df915dc71ce">Layer::createRectangle</a>(Ogre::Real left, Ogre::Real top, Ogre::Real width, Ogre::Real height)
<a name="l01214"></a>01214  {
<a name="l01215"></a>01215   <a class="code" href="class_gorilla_1_1_rectangle.html">Rectangle</a>* rectangle = OGRE_NEW <a class="code" href="class_gorilla_1_1_rectangle.html">Rectangle</a>(left, top, width, height, <span class="keyword">this</span>);
<a name="l01216"></a>01216   mRectangles.push_back(rectangle);
<a name="l01217"></a>01217   <span class="keywordflow">return</span> rectangle;
<a name="l01218"></a>01218  }
<a name="l01219"></a>01219  
<a name="l01220"></a><a class="code" href="class_gorilla_1_1_layer.html#a321df43f88b5df96ee91d3012e884734">01220</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a321df43f88b5df96ee91d3012e884734">Layer::destroyRectangle</a>(<a class="code" href="class_gorilla_1_1_rectangle.html">Rectangle</a>* rectangle)
<a name="l01221"></a>01221  {
<a name="l01222"></a>01222   <span class="keywordflow">if</span> (rectangle == 0)
<a name="l01223"></a>01223    <span class="keywordflow">return</span>;
<a name="l01224"></a>01224   
<a name="l01225"></a>01225   mRectangles.erase(std::find(mRectangles.begin(), mRectangles.end(), rectangle));
<a name="l01226"></a>01226   OGRE_DELETE rectangle;
<a name="l01227"></a>01227   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01228"></a>01228  }
<a name="l01229"></a>01229  
<a name="l01230"></a><a class="code" href="class_gorilla_1_1_layer.html#ac65d00ab01ec42332bdbc6dad2176859">01230</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#ac65d00ab01ec42332bdbc6dad2176859">Layer::destroyAllRectangles</a>()
<a name="l01231"></a>01231  {
<a name="l01232"></a>01232   
<a name="l01233"></a>01233   <span class="keywordflow">for</span> (Rectangles::iterator it = mRectangles.begin(); it != mRectangles.end(); it++)
<a name="l01234"></a>01234   {
<a name="l01235"></a>01235    OGRE_DELETE (*it);
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237   
<a name="l01238"></a>01238   mRectangles.clear();
<a name="l01239"></a>01239  }
<a name="l01240"></a>01240 
<a name="l01241"></a><a class="code" href="class_gorilla_1_1_layer.html#a76f6b3fc51e7217dd7b5dc68b4885620">01241</a>  <a class="code" href="class_gorilla_1_1_polygon.html">Polygon</a>* <a class="code" href="class_gorilla_1_1_layer.html#a76f6b3fc51e7217dd7b5dc68b4885620">Layer::createPolygon</a>(Ogre::Real left, Ogre::Real top, Ogre::Real radius, Ogre::uint sides)
<a name="l01242"></a>01242  {
<a name="l01243"></a>01243   <span class="keywordflow">if</span> (sides &lt; 3)
<a name="l01244"></a>01244    sides = 3;
<a name="l01245"></a>01245   
<a name="l01246"></a>01246   <a class="code" href="class_gorilla_1_1_polygon.html">Polygon</a>* polygon = OGRE_NEW <a class="code" href="class_gorilla_1_1_polygon.html">Polygon</a>(left, top, radius, sides, <span class="keyword">this</span>);
<a name="l01247"></a>01247   mPolygons.push_back(polygon);
<a name="l01248"></a>01248   <span class="keywordflow">return</span> polygon;
<a name="l01249"></a>01249  }
<a name="l01250"></a>01250 
<a name="l01251"></a><a class="code" href="class_gorilla_1_1_layer.html#a8642aca9541a4dec0e00d890cfe37eee">01251</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a8642aca9541a4dec0e00d890cfe37eee">Layer::destroyPolygon</a>(<a class="code" href="class_gorilla_1_1_polygon.html">Polygon</a>* polygon)
<a name="l01252"></a>01252  {
<a name="l01253"></a>01253   <span class="keywordflow">if</span> (polygon == 0)
<a name="l01254"></a>01254    <span class="keywordflow">return</span>;
<a name="l01255"></a>01255   
<a name="l01256"></a>01256   mPolygons.erase(std::find(mPolygons.begin(), mPolygons.end(), polygon));
<a name="l01257"></a>01257   OGRE_DELETE polygon;
<a name="l01258"></a>01258   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01259"></a>01259  }
<a name="l01260"></a>01260 
<a name="l01261"></a><a class="code" href="class_gorilla_1_1_layer.html#a5d639003c496633bf8ca338a0cd8b930">01261</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a5d639003c496633bf8ca338a0cd8b930">Layer::destroyAllPolygons</a>()
<a name="l01262"></a>01262  {
<a name="l01263"></a>01263   
<a name="l01264"></a>01264   <span class="keywordflow">for</span> (Polygons::iterator it = mPolygons.begin(); it != mPolygons.end(); it++)
<a name="l01265"></a>01265   {
<a name="l01266"></a>01266    OGRE_DELETE (*it);
<a name="l01267"></a>01267   }
<a name="l01268"></a>01268   
<a name="l01269"></a>01269   mPolygons.clear();
<a name="l01270"></a>01270  }
<a name="l01271"></a>01271 
<a name="l01272"></a><a class="code" href="class_gorilla_1_1_layer.html#abf5dde3d5d2af8b9edb20460c37c7d23">01272</a>  <a class="code" href="class_gorilla_1_1_line_list.html">LineList</a>* <a class="code" href="class_gorilla_1_1_layer.html#abf5dde3d5d2af8b9edb20460c37c7d23">Layer::createLineList</a>()
<a name="l01273"></a>01273  {
<a name="l01274"></a>01274   <a class="code" href="class_gorilla_1_1_line_list.html">LineList</a>* linelist = OGRE_NEW <a class="code" href="class_gorilla_1_1_line_list.html">LineList</a>(<span class="keyword">this</span>);
<a name="l01275"></a>01275   mLineLists.push_back(linelist);
<a name="l01276"></a>01276   <span class="keywordflow">return</span> linelist;
<a name="l01277"></a>01277  }
<a name="l01278"></a>01278 
<a name="l01279"></a><a class="code" href="class_gorilla_1_1_layer.html#a89c1f88f29dd9d8ac0d2ea9f94f60350">01279</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a89c1f88f29dd9d8ac0d2ea9f94f60350">Layer::destroyLineList</a>(<a class="code" href="class_gorilla_1_1_line_list.html">LineList</a>* linelist)
<a name="l01280"></a>01280  {
<a name="l01281"></a>01281   <span class="keywordflow">if</span> (linelist == 0)
<a name="l01282"></a>01282    <span class="keywordflow">return</span>;
<a name="l01283"></a>01283   
<a name="l01284"></a>01284   mLineLists.erase(std::find(mLineLists.begin(), mLineLists.end(), linelist));
<a name="l01285"></a>01285   OGRE_DELETE linelist;
<a name="l01286"></a>01286   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01287"></a>01287  }
<a name="l01288"></a>01288 
<a name="l01289"></a><a class="code" href="class_gorilla_1_1_layer.html#af51fb3b28c01f52959712489920684de">01289</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#af51fb3b28c01f52959712489920684de">Layer::destroyAllLineLists</a>()
<a name="l01290"></a>01290  {
<a name="l01291"></a>01291   
<a name="l01292"></a>01292   <span class="keywordflow">for</span> (LineLists::iterator it = mLineLists.begin(); it != mLineLists.end(); it++)
<a name="l01293"></a>01293   {
<a name="l01294"></a>01294    OGRE_DELETE (*it);
<a name="l01295"></a>01295   }
<a name="l01296"></a>01296   
<a name="l01297"></a>01297   mLineLists.clear();
<a name="l01298"></a>01298  }
<a name="l01299"></a>01299 
<a name="l01300"></a><a class="code" href="class_gorilla_1_1_layer.html#af5e77ec1d14895526ce639ff9c291b74">01300</a>  <a class="code" href="class_gorilla_1_1_quad_list.html">QuadList</a>* <a class="code" href="class_gorilla_1_1_layer.html#af5e77ec1d14895526ce639ff9c291b74">Layer::createQuadList</a>()
<a name="l01301"></a>01301  {
<a name="l01302"></a>01302   <a class="code" href="class_gorilla_1_1_quad_list.html">QuadList</a>* quadlist = OGRE_NEW <a class="code" href="class_gorilla_1_1_quad_list.html">QuadList</a>(<span class="keyword">this</span>);
<a name="l01303"></a>01303   mQuadLists.push_back(quadlist);
<a name="l01304"></a>01304   <span class="keywordflow">return</span> quadlist;
<a name="l01305"></a>01305  }
<a name="l01306"></a>01306 
<a name="l01307"></a><a class="code" href="class_gorilla_1_1_layer.html#a8a0f222f53a6677423b29b135000c5d6">01307</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a8a0f222f53a6677423b29b135000c5d6">Layer::destroyQuadList</a>(<a class="code" href="class_gorilla_1_1_quad_list.html">QuadList</a>* quadlist)
<a name="l01308"></a>01308  {
<a name="l01309"></a>01309   <span class="keywordflow">if</span> (quadlist == 0)
<a name="l01310"></a>01310    <span class="keywordflow">return</span>;
<a name="l01311"></a>01311   
<a name="l01312"></a>01312   mQuadLists.erase(std::find(mQuadLists.begin(), mQuadLists.end(), quadlist));
<a name="l01313"></a>01313   OGRE_DELETE quadlist;
<a name="l01314"></a>01314   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01315"></a>01315  }
<a name="l01316"></a>01316 
<a name="l01317"></a><a class="code" href="class_gorilla_1_1_layer.html#a7053cc9dbc7a2cff1fc2e911b3f19d36">01317</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a7053cc9dbc7a2cff1fc2e911b3f19d36">Layer::destroyAllQuadLists</a>()
<a name="l01318"></a>01318  {
<a name="l01319"></a>01319   
<a name="l01320"></a>01320   <span class="keywordflow">for</span> (QuadLists::iterator it = mQuadLists.begin(); it != mQuadLists.end(); it++)
<a name="l01321"></a>01321   {
<a name="l01322"></a>01322    OGRE_DELETE (*it);
<a name="l01323"></a>01323   }
<a name="l01324"></a>01324   
<a name="l01325"></a>01325   mQuadLists.clear();
<a name="l01326"></a>01326  }
<a name="l01327"></a>01327 
<a name="l01328"></a><a class="code" href="class_gorilla_1_1_layer.html#a9ccfd1028425b66a58550168cb8ec0d9">01328</a>  <a class="code" href="class_gorilla_1_1_caption.html">Caption</a>* <a class="code" href="class_gorilla_1_1_layer.html#a9ccfd1028425b66a58550168cb8ec0d9">Layer::createCaption</a>(Ogre::uint glyphDataIndex, Ogre::Real x, Ogre::Real y, <span class="keyword">const</span> Ogre::String&amp; text)
<a name="l01329"></a>01329  {
<a name="l01330"></a>01330   <a class="code" href="class_gorilla_1_1_caption.html">Caption</a>* caption = OGRE_NEW <a class="code" href="class_gorilla_1_1_caption.html">Caption</a>(glyphDataIndex,x, y, text, <span class="keyword">this</span>);
<a name="l01331"></a>01331   mCaptions.push_back(caption);
<a name="l01332"></a>01332   <span class="keywordflow">return</span> caption;
<a name="l01333"></a>01333  }
<a name="l01334"></a>01334 
<a name="l01335"></a><a class="code" href="class_gorilla_1_1_layer.html#a618bc7047cdcc0420be0f37ac69fdab8">01335</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a618bc7047cdcc0420be0f37ac69fdab8">Layer::destroyCaption</a>(<a class="code" href="class_gorilla_1_1_caption.html">Caption</a>* caption)
<a name="l01336"></a>01336  {
<a name="l01337"></a>01337   <span class="keywordflow">if</span> (caption == 0)
<a name="l01338"></a>01338    <span class="keywordflow">return</span>;
<a name="l01339"></a>01339   
<a name="l01340"></a>01340   mCaptions.erase(std::find(mCaptions.begin(), mCaptions.end(), caption));
<a name="l01341"></a>01341   OGRE_DELETE caption;
<a name="l01342"></a>01342   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01343"></a>01343  }
<a name="l01344"></a>01344 
<a name="l01345"></a><a class="code" href="class_gorilla_1_1_layer.html#a84dfd109b772d00a4e5e39544f3e8612">01345</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a84dfd109b772d00a4e5e39544f3e8612">Layer::destroyAllCaptions</a>()
<a name="l01346"></a>01346  {
<a name="l01347"></a>01347   
<a name="l01348"></a>01348   <span class="keywordflow">for</span> (Captions::iterator it = mCaptions.begin(); it != mCaptions.end(); it++)
<a name="l01349"></a>01349   {
<a name="l01350"></a>01350    OGRE_DELETE (*it);
<a name="l01351"></a>01351   }
<a name="l01352"></a>01352   
<a name="l01353"></a>01353   mCaptions.clear();
<a name="l01354"></a>01354  }
<a name="l01355"></a>01355 
<a name="l01356"></a><a class="code" href="class_gorilla_1_1_layer.html#ad36c79c230ad6c4f92138268882a3b3c">01356</a>  <a class="code" href="class_gorilla_1_1_markup_text.html">MarkupText</a>* <a class="code" href="class_gorilla_1_1_layer.html#ad36c79c230ad6c4f92138268882a3b3c">Layer::createMarkupText</a>(Ogre::uint defaultGlyphIndex, Ogre::Real x, Ogre::Real y, <span class="keyword">const</span> Ogre::String&amp; text)
<a name="l01357"></a>01357  {
<a name="l01358"></a>01358   <a class="code" href="class_gorilla_1_1_markup_text.html">MarkupText</a>* markuptext = OGRE_NEW <a class="code" href="class_gorilla_1_1_markup_text.html">MarkupText</a>(defaultGlyphIndex, x, y, text, <span class="keyword">this</span>);
<a name="l01359"></a>01359   mMarkupTexts.push_back(markuptext);
<a name="l01360"></a>01360   <span class="keywordflow">return</span> markuptext;
<a name="l01361"></a>01361  }
<a name="l01362"></a>01362 
<a name="l01363"></a><a class="code" href="class_gorilla_1_1_layer.html#a4db7f2f78229d3c8809a33920495a282">01363</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#a4db7f2f78229d3c8809a33920495a282">Layer::destroyMarkupText</a>(<a class="code" href="class_gorilla_1_1_markup_text.html">MarkupText</a>* markuptext)
<a name="l01364"></a>01364  {
<a name="l01365"></a>01365   <span class="keywordflow">if</span> (markuptext == 0)
<a name="l01366"></a>01366    <span class="keywordflow">return</span>;
<a name="l01367"></a>01367   
<a name="l01368"></a>01368   mMarkupTexts.erase(std::find(mMarkupTexts.begin(), mMarkupTexts.end(), markuptext));
<a name="l01369"></a>01369   OGRE_DELETE markuptext;
<a name="l01370"></a>01370   <a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01371"></a>01371  }
<a name="l01372"></a>01372 
<a name="l01373"></a><a class="code" href="class_gorilla_1_1_layer.html#ad956895440c5351dc635901cce57e318">01373</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_layer.html#ad956895440c5351dc635901cce57e318">Layer::destroyAllMarkupTexts</a>()
<a name="l01374"></a>01374  {
<a name="l01375"></a>01375   
<a name="l01376"></a>01376   <span class="keywordflow">for</span> (MarkupTexts::iterator it = mMarkupTexts.begin(); it != mMarkupTexts.end(); it++)
<a name="l01377"></a>01377   {
<a name="l01378"></a>01378    OGRE_DELETE (*it);
<a name="l01379"></a>01379   }
<a name="l01380"></a>01380   
<a name="l01381"></a>01381   mMarkupTexts.clear();
<a name="l01382"></a>01382  }
<a name="l01383"></a>01383 
<a name="l01384"></a>01384  <span class="keywordtype">void</span> Layer::_render(<a class="code" href="class_gorilla_1_1buffer.html">buffer&lt;Vertex&gt;</a>&amp; vertices, <span class="keywordtype">bool</span> force)
<a name="l01385"></a>01385  {
<a name="l01386"></a>01386   
<a name="l01387"></a>01387   <span class="keywordflow">if</span> (mAlphaModifier == 0.0f)
<a name="l01388"></a>01388    <span class="keywordflow">return</span>;
<a name="l01389"></a>01389   
<a name="l01390"></a>01390   <span class="keywordtype">size_t</span> begin = vertices.size();
<a name="l01391"></a>01391   <span class="keywordtype">size_t</span> i = 0;
<a name="l01392"></a>01392   
<a name="l01393"></a>01393   <span class="comment">// Render/redraw rectangles</span>
<a name="l01394"></a>01394   <span class="keywordflow">for</span> (Rectangles::iterator it = mRectangles.begin(); it != mRectangles.end(); it++)
<a name="l01395"></a>01395   {
<a name="l01396"></a>01396    
<a name="l01397"></a>01397    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01398"></a>01398     (*it)-&gt;_redraw();
<a name="l01399"></a>01399   
<a name="l01400"></a>01400    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01401"></a>01401     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01402"></a>01402   
<a name="l01403"></a>01403   }
<a name="l01404"></a>01404   
<a name="l01405"></a>01405   <span class="comment">// Render/redraw polygons</span>
<a name="l01406"></a>01406   <span class="keywordflow">for</span> (Polygons::iterator it = mPolygons.begin(); it != mPolygons.end(); it++)
<a name="l01407"></a>01407   {
<a name="l01408"></a>01408    
<a name="l01409"></a>01409    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01410"></a>01410     (*it)-&gt;_redraw();
<a name="l01411"></a>01411   
<a name="l01412"></a>01412    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01413"></a>01413     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01414"></a>01414   
<a name="l01415"></a>01415   }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417   <span class="comment">// Render/redraw line lists</span>
<a name="l01418"></a>01418   <span class="keywordflow">for</span> (LineLists::iterator it = mLineLists.begin(); it != mLineLists.end(); it++)
<a name="l01419"></a>01419   {
<a name="l01420"></a>01420    
<a name="l01421"></a>01421    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01422"></a>01422     (*it)-&gt;_redraw();
<a name="l01423"></a>01423   
<a name="l01424"></a>01424    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01425"></a>01425     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01426"></a>01426   
<a name="l01427"></a>01427   }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   <span class="comment">// Render/redraw quad lists</span>
<a name="l01430"></a>01430   <span class="keywordflow">for</span> (QuadLists::iterator it = mQuadLists.begin(); it != mQuadLists.end(); it++)
<a name="l01431"></a>01431   {
<a name="l01432"></a>01432    
<a name="l01433"></a>01433    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01434"></a>01434     (*it)-&gt;_redraw();
<a name="l01435"></a>01435   
<a name="l01436"></a>01436    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01437"></a>01437     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01438"></a>01438   
<a name="l01439"></a>01439   }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441   <span class="comment">// Render/redraw caption</span>
<a name="l01442"></a>01442   <span class="keywordflow">for</span> (Captions::iterator it = mCaptions.begin(); it != mCaptions.end(); it++)
<a name="l01443"></a>01443   {
<a name="l01444"></a>01444    
<a name="l01445"></a>01445    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01446"></a>01446     (*it)-&gt;_redraw();
<a name="l01447"></a>01447   
<a name="l01448"></a>01448    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01449"></a>01449     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01450"></a>01450   
<a name="l01451"></a>01451   }
<a name="l01452"></a>01452   
<a name="l01453"></a>01453   <span class="comment">// Render/redraw caption</span>
<a name="l01454"></a>01454   <span class="keywordflow">for</span> (MarkupTexts::iterator it = mMarkupTexts.begin(); it != mMarkupTexts.end(); it++)
<a name="l01455"></a>01455   {
<a name="l01456"></a>01456    
<a name="l01457"></a>01457    <span class="keywordflow">if</span> ((*it)-&gt;mTextDirty || force)
<a name="l01458"></a>01458     (*it)-&gt;_calculateCharacters();
<a name="l01459"></a>01459    
<a name="l01460"></a>01460    <span class="keywordflow">if</span> ((*it)-&gt;mDirty || force)
<a name="l01461"></a>01461     (*it)-&gt;_redraw();
<a name="l01462"></a>01462   
<a name="l01463"></a>01463    <span class="keywordflow">for</span> (i=0; i &lt; (*it)-&gt;mVertices.size(); i++)
<a name="l01464"></a>01464     vertices.push_back((*it)-&gt;mVertices[i]);
<a name="l01465"></a>01465   
<a name="l01466"></a>01466   }
<a name="l01467"></a>01467   
<a name="l01468"></a>01468   <span class="keywordflow">if</span> (mAlphaModifier != 1.0f)
<a name="l01469"></a>01469   {
<a name="l01470"></a>01470    <span class="keywordflow">for</span> (i=begin;i &lt; vertices.size();i++)
<a name="l01471"></a>01471     vertices[i].colour.a *= mAlphaModifier;
<a name="l01472"></a>01472   }
<a name="l01473"></a>01473   
<a name="l01474"></a>01474   mParent-&gt;_transform(vertices, begin, vertices.size());
<a name="l01475"></a>01475   
<a name="l01476"></a>01476  }
<a name="l01477"></a>01477  
<a name="l01478"></a>01478  
<a name="l01479"></a>01479  Rectangle::Rectangle(Ogre::Real left, Ogre::Real top, Ogre::Real width, Ogre::Real height, Layer* layer) : mLayer(layer)
<a name="l01480"></a>01480  {
<a name="l01481"></a>01481   mDirty       = <span class="keyword">true</span>;
<a name="l01482"></a>01482   mLeft        = left;
<a name="l01483"></a>01483   mTop         = top;
<a name="l01484"></a>01484   mRight       = left + width;
<a name="l01485"></a>01485   mBottom      = top + height;
<a name="l01486"></a>01486   mBorderWidth = 0.0f;
<a name="l01487"></a>01487   mBackgroundColour[0] = mBackgroundColour[1] =  mBackgroundColour[2] = mBackgroundColour[3] = Ogre::ColourValue::White;
<a name="l01488"></a>01488   mUV[0] = mUV[1] = mUV[2] = mUV[3] = mLayer-&gt;_getSolidUV();
<a name="l01489"></a>01489   
<a name="l01490"></a>01490  }
<a name="l01491"></a>01491  
<a name="l01492"></a>01492  
<a name="l01493"></a><a class="code" href="class_gorilla_1_1_rectangle.html#a3c6d321d4d1001341fc4f8737148a5e9">01493</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_rectangle.html#a3c6d321d4d1001341fc4f8737148a5e9">Rectangle::_redraw</a>()
<a name="l01494"></a>01494  {
<a name="l01495"></a>01495   
<a name="l01496"></a>01496   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l01497"></a>01497    <span class="keywordflow">return</span>;
<a name="l01498"></a>01498   
<a name="l01499"></a>01499   mVertices.remove_all();
<a name="l01500"></a>01500 
<a name="l01501"></a>01501   Ogre::Real texelOffsetX = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a67d1c135a2083ffc567fbd7143bec6fa">_getTexelX</a>(), texelOffsetY = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a6510587c01e71557bf1f0a62a7447673">_getTexelY</a>();
<a name="l01502"></a>01502   Ogre::Vector2 a, b, c, d;
<a name="l01503"></a>01503   a.x = mLeft  + texelOffsetX; a.y = mTop    + texelOffsetY;
<a name="l01504"></a>01504   b.x = mRight + texelOffsetX; b.y = mTop    + texelOffsetY;
<a name="l01505"></a>01505   c.x = mLeft  + texelOffsetX; c.y = mBottom + texelOffsetY;
<a name="l01506"></a>01506   d.x = mRight + texelOffsetX; d.y = mBottom + texelOffsetY;
<a name="l01507"></a>01507   
<a name="l01508"></a>01508   <span class="comment">// Border</span>
<a name="l01509"></a>01509   <span class="keywordflow">if</span> (mBorderWidth != 0)
<a name="l01510"></a>01510   {
<a name="l01511"></a>01511     Ogre::Vector2 i = a, j = b, k = c, l = d;
<a name="l01512"></a>01512     i.x -= mBorderWidth;    i.y -= mBorderWidth;
<a name="l01513"></a>01513     j.x += mBorderWidth;    j.y -= mBorderWidth;
<a name="l01514"></a>01514     k.x -= mBorderWidth;    k.y += mBorderWidth;
<a name="l01515"></a>01515     l.x += mBorderWidth;    l.y += mBorderWidth;
<a name="l01516"></a>01516     
<a name="l01517"></a>01517     <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l01518"></a>01518     Ogre::Vector2 uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01519"></a>01519     
<a name="l01520"></a>01520     <span class="comment">// North</span>
<a name="l01521"></a>01521     PUSH_TRIANGLE(mVertices, temp, a, j, i, uv, mBorderColour[Border_North])
<a name="l01522"></a>01522     PUSH_TRIANGLE(mVertices, temp, a, b, j, uv, mBorderColour[Border_North])
<a name="l01523"></a>01523     
<a name="l01524"></a>01524     <span class="comment">// East</span>
<a name="l01525"></a>01525     PUSH_TRIANGLE(mVertices, temp, d, j, b, uv, mBorderColour[Border_East])
<a name="l01526"></a>01526     PUSH_TRIANGLE(mVertices, temp, d, l, j, uv, mBorderColour[Border_East])
<a name="l01527"></a>01527     
<a name="l01528"></a>01528     <span class="comment">// South</span>
<a name="l01529"></a>01529     PUSH_TRIANGLE(mVertices, temp, k, d, c, uv, mBorderColour[Border_South])
<a name="l01530"></a>01530     PUSH_TRIANGLE(mVertices, temp, k, l, d, uv, mBorderColour[Border_South])
<a name="l01531"></a>01531     
<a name="l01532"></a>01532     <span class="comment">// West</span>
<a name="l01533"></a>01533     PUSH_TRIANGLE(mVertices, temp, k, a, i, uv, mBorderColour[Border_West])
<a name="l01534"></a>01534     PUSH_TRIANGLE(mVertices, temp, k, c, a, uv, mBorderColour[Border_West])
<a name="l01535"></a>01535     
<a name="l01536"></a>01536   }
<a name="l01537"></a>01537   
<a name="l01538"></a>01538   <span class="comment">// Fill</span>
<a name="l01539"></a>01539   <span class="keywordflow">if</span> (mBackgroundColour[0].a != 0)
<a name="l01540"></a>01540   {
<a name="l01541"></a>01541    <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l01542"></a>01542    <span class="comment">// Triangle A</span>
<a name="l01543"></a>01543    PUSH_VERTEX(mVertices, temp, c.x, c.y, mUV[3], mBackgroundColour[3]);    <span class="comment">// Left/Bottom  3</span>
<a name="l01544"></a>01544    PUSH_VERTEX(mVertices, temp, b.x, b.y, mUV[1], mBackgroundColour[1]);    <span class="comment">// Right/Top    1</span>
<a name="l01545"></a>01545    PUSH_VERTEX(mVertices, temp, a.x, a.y, mUV[0], mBackgroundColour[0]);    <span class="comment">// Left/Top     0</span>
<a name="l01546"></a>01546    
<a name="l01547"></a>01547    <span class="comment">// Triangle B</span>
<a name="l01548"></a>01548    PUSH_VERTEX(mVertices, temp, c.x, c.y, mUV[3], mBackgroundColour[3]);    <span class="comment">// Left/Bottom   3</span>
<a name="l01549"></a>01549    PUSH_VERTEX(mVertices, temp, d.x, d.y, mUV[2], mBackgroundColour[2]);    <span class="comment">// Right/Bottom  2</span>
<a name="l01550"></a>01550    PUSH_VERTEX(mVertices, temp, b.x, b.y, mUV[1], mBackgroundColour[1]);    <span class="comment">// Right/Top     1</span>
<a name="l01551"></a>01551   }
<a name="l01552"></a>01552   
<a name="l01553"></a>01553   mDirty = <span class="keyword">false</span>;
<a name="l01554"></a>01554   
<a name="l01555"></a>01555  }
<a name="l01556"></a>01556  
<a name="l01557"></a>01557 Polygon::Polygon(Ogre::Real left, Ogre::Real top, Ogre::Real radius, <span class="keywordtype">size_t</span> sides, <a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* layer)
<a name="l01558"></a>01558  : mLayer(layer), mSprite(0)
<a name="l01559"></a>01559  {
<a name="l01560"></a>01560   mDirty        = <span class="keyword">true</span>;
<a name="l01561"></a>01561   mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01562"></a>01562   mLeft           = left;
<a name="l01563"></a>01563   mTop            = top;
<a name="l01564"></a>01564   mRadius         = radius;
<a name="l01565"></a>01565   mSides          = sides;
<a name="l01566"></a>01566   mBackgroundColour         = Ogre::ColourValue::White;
<a name="l01567"></a>01567   mBorderColour.a = 0;
<a name="l01568"></a>01568   mBorderWidth    = 0;
<a name="l01569"></a>01569  }
<a name="l01570"></a>01570  
<a name="l01571"></a><a class="code" href="class_gorilla_1_1_polygon.html#a83b5138fcd0e13a8babd05150dcf28b3">01571</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_polygon.html#a83b5138fcd0e13a8babd05150dcf28b3">Polygon::_redraw</a>()
<a name="l01572"></a>01572  {
<a name="l01573"></a>01573   
<a name="l01574"></a>01574   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l01575"></a>01575    <span class="keywordflow">return</span>;
<a name="l01576"></a>01576   
<a name="l01577"></a>01577   mVertices.remove_all();
<a name="l01578"></a>01578   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l01579"></a>01579   
<a name="l01580"></a>01580   Ogre::Real theta = mAngle.valueRadians();
<a name="l01581"></a>01581   Ogre::Real inc = (2 * Ogre::Math::PI) / Ogre::Real(mSides);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   Ogre::Vector2 lastVertex;
<a name="l01584"></a>01584   lastVertex.x = mLeft + (mRadius * cos(theta));
<a name="l01585"></a>01585   lastVertex.y = mTop + (mRadius * sin(theta));
<a name="l01586"></a>01586   Ogre::Vector2 thisVertex;
<a name="l01587"></a>01587   
<a name="l01588"></a>01588   <span class="keywordflow">if</span> (mBorderWidth != 0)
<a name="l01589"></a>01589   {
<a name="l01590"></a>01590    
<a name="l01591"></a>01591    Ogre::Vector2 lastOuterVertex, outerVertex, thisVertex, uv;
<a name="l01592"></a>01592    uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01593"></a>01593     
<a name="l01594"></a>01594    lastOuterVertex.x = mLeft + ((mRadius + mBorderWidth) * cos(theta));
<a name="l01595"></a>01595    lastOuterVertex.y = mTop + ((mRadius + mBorderWidth) * sin(theta));
<a name="l01596"></a>01596    
<a name="l01597"></a>01597    
<a name="l01598"></a>01598    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mSides;i++)
<a name="l01599"></a>01599    {
<a name="l01600"></a>01600     theta += inc;
<a name="l01601"></a>01601     thisVertex.x = mLeft + (mRadius * Ogre::Math::Cos(theta));
<a name="l01602"></a>01602     thisVertex.y = mTop + (mRadius * Ogre::Math::Sin(theta));
<a name="l01603"></a>01603     outerVertex.x = mLeft + ((mRadius + mBorderWidth) * Ogre::Math::Cos(theta));
<a name="l01604"></a>01604     outerVertex.y = mTop + ((mRadius + mBorderWidth) * Ogre::Math::Sin(theta));
<a name="l01605"></a>01605     
<a name="l01606"></a>01606     PUSH_TRIANGLE(mVertices, temp, lastVertex, outerVertex, lastOuterVertex, uv, mBorderColour);
<a name="l01607"></a>01607     PUSH_TRIANGLE(mVertices, temp, lastVertex, thisVertex, outerVertex, uv, mBorderColour);
<a name="l01608"></a>01608     
<a name="l01609"></a>01609     lastVertex = thisVertex;
<a name="l01610"></a>01610     lastOuterVertex = outerVertex;
<a name="l01611"></a>01611    }
<a name="l01612"></a>01612   }
<a name="l01613"></a>01613   
<a name="l01614"></a>01614   <span class="keywordflow">if</span> (mBackgroundColour.a != 0)
<a name="l01615"></a>01615   {
<a name="l01616"></a>01616      <span class="keywordflow">if</span> (mSprite)
<a name="l01617"></a>01617      {
<a name="l01618"></a>01618       Ogre::Real xRadius = mSprite-&gt;spriteWidth * 0.5f;
<a name="l01619"></a>01619       Ogre::Real yRadius = mSprite-&gt;spriteHeight * 0.5f;
<a name="l01620"></a>01620       
<a name="l01621"></a>01621       Ogre::Vector2 centerUV, lastUV, thisUV, baseUV, texSize = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a119de27263ad15267e5292211b6ee3e0">_getTextureSize</a>();
<a name="l01622"></a>01622       baseUV.x = mSprite-&gt;uvLeft * texSize.x;
<a name="l01623"></a>01623       baseUV.y = mSprite-&gt;uvTop * texSize.y;
<a name="l01624"></a>01624       baseUV.x += xRadius;
<a name="l01625"></a>01625       baseUV.y += yRadius;
<a name="l01626"></a>01626       
<a name="l01627"></a>01627       centerUV = baseUV / texSize;
<a name="l01628"></a>01628       lastUV = baseUV;
<a name="l01629"></a>01629       lastUV.x = baseUV.x + (xRadius * Ogre::Math::Cos(theta));
<a name="l01630"></a>01630       lastUV.y = baseUV.y + (yRadius * Ogre::Math::Sin(theta));
<a name="l01631"></a>01631       lastUV /= texSize;
<a name="l01632"></a>01632       
<a name="l01633"></a>01633       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mSides;i++)
<a name="l01634"></a>01634       {
<a name="l01635"></a>01635        PUSH_VERTEX(mVertices, temp, mLeft, mTop, centerUV, mBackgroundColour);
<a name="l01636"></a>01636        theta += inc;
<a name="l01637"></a>01637        thisVertex.x = mLeft + (mRadius * Ogre::Math::Cos(theta));
<a name="l01638"></a>01638        thisVertex.y = mTop + (mRadius * Ogre::Math::Sin(theta));
<a name="l01639"></a>01639        thisUV.x = baseUV.x + (xRadius * Ogre::Math::Cos(theta));
<a name="l01640"></a>01640        thisUV.y = baseUV.y + (yRadius * Ogre::Math::Sin(theta));
<a name="l01641"></a>01641        thisUV /= texSize;
<a name="l01642"></a>01642        PUSH_VERTEX(mVertices, temp, thisVertex.x, thisVertex.y, thisUV, mBackgroundColour);
<a name="l01643"></a>01643        PUSH_VERTEX(mVertices, temp, lastVertex.x, lastVertex.y, lastUV, mBackgroundColour);
<a name="l01644"></a>01644        lastVertex = thisVertex;
<a name="l01645"></a>01645        lastUV = thisUV;
<a name="l01646"></a>01646       }
<a name="l01647"></a>01647      }
<a name="l01648"></a>01648      <span class="keywordflow">else</span>
<a name="l01649"></a>01649      {
<a name="l01650"></a>01650       Ogre::Vector2 uv = uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01651"></a>01651       
<a name="l01652"></a>01652       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mSides;i++)
<a name="l01653"></a>01653       {
<a name="l01654"></a>01654        PUSH_VERTEX(mVertices, temp, mLeft, mTop, uv, mBackgroundColour);
<a name="l01655"></a>01655        theta += inc;
<a name="l01656"></a>01656        thisVertex.x = mLeft + (mRadius * Ogre::Math::Cos(theta));
<a name="l01657"></a>01657        thisVertex.y = mTop + (mRadius * Ogre::Math::Sin(theta));
<a name="l01658"></a>01658        PUSH_VERTEX(mVertices, temp, thisVertex.x, thisVertex.y, uv, mBackgroundColour);
<a name="l01659"></a>01659        PUSH_VERTEX(mVertices, temp, lastVertex.x, lastVertex.y, uv, mBackgroundColour);
<a name="l01660"></a>01660        lastVertex = thisVertex;
<a name="l01661"></a>01661       }
<a name="l01662"></a>01662      }
<a name="l01663"></a>01663   }
<a name="l01664"></a>01664   
<a name="l01665"></a>01665   mDirty = <span class="keyword">false</span>;
<a name="l01666"></a>01666   
<a name="l01667"></a>01667  }
<a name="l01668"></a>01668  
<a name="l01669"></a>01669 
<a name="l01670"></a>01670 
<a name="l01671"></a>01671  LineList::LineList(<a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* layer) : mLayer(layer)
<a name="l01672"></a>01672  {
<a name="l01673"></a>01673   mDirty = <span class="keyword">false</span>;
<a name="l01674"></a>01674  }
<a name="l01675"></a>01675  
<a name="l01676"></a><a class="code" href="class_gorilla_1_1_line_list.html#a2ef894c831ee0b51585df4126d3a50de">01676</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_line_list.html#a2ef894c831ee0b51585df4126d3a50de">LineList::begin</a>(Ogre::Real lineThickness, <span class="keyword">const</span> Ogre::ColourValue&amp; colour)
<a name="l01677"></a>01677  {
<a name="l01678"></a>01678   mDirty = <span class="keyword">false</span>;
<a name="l01679"></a>01679   mPositions.remove_all();
<a name="l01680"></a>01680   mThickness = lineThickness;
<a name="l01681"></a>01681   mColour = colour;
<a name="l01682"></a>01682  }
<a name="l01683"></a>01683  
<a name="l01684"></a><a class="code" href="class_gorilla_1_1_line_list.html#a5278d586857169a870b38593435cd378">01684</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_line_list.html#a5278d586857169a870b38593435cd378">LineList::position</a>(Ogre::Real x, Ogre::Real y)
<a name="l01685"></a>01685  {
<a name="l01686"></a>01686   mPositions.push_back(Ogre::Vector2(x,y));
<a name="l01687"></a>01687  }
<a name="l01688"></a>01688  
<a name="l01689"></a><a class="code" href="class_gorilla_1_1_line_list.html#a3080dbc3eec3df40f307a7da5297e99b">01689</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_line_list.html#a5278d586857169a870b38593435cd378">LineList::position</a>(<span class="keyword">const</span> Ogre::Vector2&amp; position)
<a name="l01690"></a>01690  {
<a name="l01691"></a>01691   mPositions.push_back(position);
<a name="l01692"></a>01692  }
<a name="l01693"></a>01693  
<a name="l01694"></a><a class="code" href="class_gorilla_1_1_line_list.html#ac69849ca25e2af72761bb9ea53225128">01694</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_line_list.html#ac69849ca25e2af72761bb9ea53225128">LineList::end</a>(<span class="keywordtype">bool</span> closed)
<a name="l01695"></a>01695  {
<a name="l01696"></a>01696   mIsClosed = closed;
<a name="l01697"></a>01697   mDirty = <span class="keyword">true</span>;
<a name="l01698"></a>01698  }
<a name="l01699"></a>01699  
<a name="l01700"></a><a class="code" href="class_gorilla_1_1_line_list.html#a403e7a9b4c067d9e6b76725f5ab135ed">01700</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_line_list.html#a403e7a9b4c067d9e6b76725f5ab135ed">LineList::_redraw</a>()
<a name="l01701"></a>01701  {
<a name="l01702"></a>01702   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l01703"></a>01703    <span class="keywordflow">return</span>;
<a name="l01704"></a>01704   
<a name="l01705"></a>01705   mVertices.remove_all();
<a name="l01706"></a>01706   
<a name="l01707"></a>01707   <span class="keywordflow">if</span> (mPositions.size() &lt; 2)
<a name="l01708"></a>01708    <span class="keywordflow">return</span>;
<a name="l01709"></a>01709   
<a name="l01710"></a>01710   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l01711"></a>01711   
<a name="l01712"></a>01712   Ogre::Real halfThickness = mThickness * 0.5f;
<a name="l01713"></a>01713   
<a name="l01714"></a>01714   Ogre::Vector2 perp, lastLeft, lastRight, thisLeft, thisRight, uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01715"></a>01715   
<a name="l01716"></a>01716   <span class="keywordtype">size_t</span> i = 1;
<a name="l01717"></a>01717   
<a name="l01718"></a>01718   <span class="keywordflow">for</span> (;i &lt; mPositions.size();i++)
<a name="l01719"></a>01719   {
<a name="l01720"></a>01720    
<a name="l01721"></a>01721    perp      = (mPositions[i] - mPositions[i-1]).perpendicular().normalisedCopy();
<a name="l01722"></a>01722    lastLeft  = mPositions[i-1] - perp * halfThickness;
<a name="l01723"></a>01723    lastRight = mPositions[i-1] + perp * halfThickness;
<a name="l01724"></a>01724    thisLeft  = mPositions[i] - perp * halfThickness;
<a name="l01725"></a>01725    thisRight = mPositions[i] + perp * halfThickness;
<a name="l01726"></a>01726    
<a name="l01727"></a>01727    <span class="comment">// Triangle A</span>
<a name="l01728"></a>01728    PUSH_VERTEX(mVertices, temp, lastRight.x, lastRight.y, uv, mColour);       <span class="comment">// Left/Bottom</span>
<a name="l01729"></a>01729    PUSH_VERTEX(mVertices, temp, thisLeft.x, thisLeft.y, uv, mColour);         <span class="comment">// Right/Top</span>
<a name="l01730"></a>01730    PUSH_VERTEX(mVertices, temp, lastLeft.x, lastLeft.y, uv, mColour);          <span class="comment">// Left/Top</span>
<a name="l01731"></a>01731    <span class="comment">// Triangle B</span>
<a name="l01732"></a>01732    PUSH_VERTEX(mVertices, temp, lastRight.x, lastRight.y, uv, mColour);       <span class="comment">// Left/Bottom</span>
<a name="l01733"></a>01733    PUSH_VERTEX(mVertices, temp, thisRight.x, thisRight.y, uv, mColour);      <span class="comment">// Right/Bottom</span>
<a name="l01734"></a>01734    PUSH_VERTEX(mVertices, temp, thisLeft.x, thisLeft.y, uv, mColour);         <span class="comment">// Right/Top</span>
<a name="l01735"></a>01735    
<a name="l01736"></a>01736   }
<a name="l01737"></a>01737   
<a name="l01738"></a>01738   <span class="keywordflow">if</span> (mIsClosed)
<a name="l01739"></a>01739   {
<a name="l01740"></a>01740    i = mPositions.size() - 1;
<a name="l01741"></a>01741    perp      = (mPositions[0] - mPositions[i]).perpendicular().normalisedCopy();
<a name="l01742"></a>01742    lastLeft  = mPositions[i] - perp * halfThickness;
<a name="l01743"></a>01743    lastRight = mPositions[i] + perp * halfThickness;
<a name="l01744"></a>01744    thisLeft  = mPositions[0] - perp * halfThickness;
<a name="l01745"></a>01745    thisRight = mPositions[0] + perp * halfThickness;
<a name="l01746"></a>01746    
<a name="l01747"></a>01747    <span class="comment">// Triangle A</span>
<a name="l01748"></a>01748    PUSH_VERTEX(mVertices, temp, lastRight.x, lastRight.y, uv, mColour);       <span class="comment">// Left/Bottom</span>
<a name="l01749"></a>01749    PUSH_VERTEX(mVertices, temp, thisLeft.x, thisLeft.y, uv, mColour);         <span class="comment">// Right/Top</span>
<a name="l01750"></a>01750    PUSH_VERTEX(mVertices, temp, lastLeft.x, lastLeft.y, uv, mColour);          <span class="comment">// Left/Top</span>
<a name="l01751"></a>01751    <span class="comment">// Triangle B</span>
<a name="l01752"></a>01752    PUSH_VERTEX(mVertices, temp, lastRight.x, lastRight.y, uv, mColour);       <span class="comment">// Left/Bottom</span>
<a name="l01753"></a>01753    PUSH_VERTEX(mVertices, temp, thisRight.x, thisRight.y, uv, mColour);      <span class="comment">// Right/Bottom</span>
<a name="l01754"></a>01754    PUSH_VERTEX(mVertices, temp, thisLeft.x, thisLeft.y, uv, mColour);         <span class="comment">// Right/Top</span>
<a name="l01755"></a>01755    
<a name="l01756"></a>01756   }
<a name="l01757"></a>01757   
<a name="l01758"></a>01758  }
<a name="l01759"></a>01759 
<a name="l01760"></a>01760  QuadList::QuadList(<a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* layer)
<a name="l01761"></a>01761  : mLayer(layer)
<a name="l01762"></a>01762  {
<a name="l01763"></a>01763   mWhiteUV = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01764"></a>01764  }
<a name="l01765"></a>01765  
<a name="l01766"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a77a6fedd07396ababba42b529d423d88">01766</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a77a6fedd07396ababba42b529d423d88">QuadList::begin</a>()
<a name="l01767"></a>01767  {
<a name="l01768"></a>01768   mQuads.remove_all();
<a name="l01769"></a>01769   mDirty = <span class="keyword">false</span>;
<a name="l01770"></a>01770  }
<a name="l01771"></a>01771 
<a name="l01772"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a2ec866313266b9192d5b7baea9da894d">01772</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a2ec866313266b9192d5b7baea9da894d">QuadList::rectangle</a>(Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, <span class="keyword">const</span> Ogre::ColourValue colour)
<a name="l01773"></a>01773  {
<a name="l01774"></a>01774   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01775"></a>01775   q.mPosition[TopLeft].x = x; q.mPosition[TopLeft].y = y;
<a name="l01776"></a>01776   q.mPosition[TopRight].x = x + w; q.mPosition[TopRight].y = y;
<a name="l01777"></a>01777   q.mPosition[BottomRight].x = x + w; q.mPosition[BottomRight].y = y + h;
<a name="l01778"></a>01778   q.mPosition[BottomLeft].x = x; q.mPosition[BottomLeft].y = y + h;
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 
<a name="l01781"></a>01781   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = colour;
<a name="l01782"></a>01782   q.mUV[0] = q.mUV[1] = q.mUV[2] = q.mUV[3] = mWhiteUV;
<a name="l01783"></a>01783   mQuads.push_back(q);
<a name="l01784"></a>01784  }
<a name="l01785"></a>01785  
<a name="l01786"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a67abadea241ebf249b8c3ba549331ce6">01786</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a67abadea241ebf249b8c3ba549331ce6">QuadList::gradient</a>(Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, Gradient gradient, <span class="keyword">const</span> Ogre::ColourValue&amp; colourA, <span class="keyword">const</span> Ogre::ColourValue&amp; colourB)
<a name="l01787"></a>01787  {
<a name="l01788"></a>01788   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01789"></a>01789   <span class="keywordflow">if</span> (gradient == Gradient_NorthSouth)
<a name="l01790"></a>01790   {
<a name="l01791"></a>01791    q.mColour[0] = q.mColour[1] = colourA;
<a name="l01792"></a>01792    q.mColour[2] = q.mColour[3] = colourB;
<a name="l01793"></a>01793   }
<a name="l01794"></a>01794   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gradient == Gradient_WestEast)
<a name="l01795"></a>01795   {
<a name="l01796"></a>01796    q.mColour[0] = q.mColour[3] = colourA;
<a name="l01797"></a>01797    q.mColour[1] = q.mColour[2] = colourB;
<a name="l01798"></a>01798   }
<a name="l01799"></a>01799   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gradient == Gradient_Diagonal)
<a name="l01800"></a>01800   {
<a name="l01801"></a>01801    Ogre::ColourValue avg;
<a name="l01802"></a>01802    avg.r = (colourA.r + colourB.r) * 0.5f;
<a name="l01803"></a>01803    avg.g = (colourA.g + colourB.g) * 0.5f;
<a name="l01804"></a>01804    avg.b = (colourA.b + colourB.b) * 0.5f;
<a name="l01805"></a>01805    avg.a = (colourA.a + colourB.a) * 0.5f;
<a name="l01806"></a>01806    q.mColour[0] = colourA;
<a name="l01807"></a>01807    q.mColour[1] = avg = q.mColour[3] = avg;
<a name="l01808"></a>01808    q.mColour[2] = colourB;
<a name="l01809"></a>01809   }
<a name="l01810"></a>01810   
<a name="l01811"></a>01811   q.mPosition[TopLeft].x = x; q.mPosition[TopLeft].y = y;
<a name="l01812"></a>01812   q.mPosition[TopRight].x = x + w; q.mPosition[TopRight].y = y;
<a name="l01813"></a>01813   q.mPosition[BottomRight].x = x + w; q.mPosition[BottomRight].y = y + h;
<a name="l01814"></a>01814   q.mPosition[BottomLeft].x = x; q.mPosition[BottomLeft].y = y + h;
<a name="l01815"></a>01815   
<a name="l01816"></a>01816   q.mUV[0] = q.mUV[1] = q.mUV[2] = q.mUV[3] = mWhiteUV;
<a name="l01817"></a>01817   mQuads.push_back(q);
<a name="l01818"></a>01818  }
<a name="l01819"></a>01819  
<a name="l01820"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a1a04ecf4bbd065e4eedf2d20af72f9dc">01820</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a1a04ecf4bbd065e4eedf2d20af72f9dc">QuadList::sprite</a>(Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, <a class="code" href="class_gorilla_1_1_sprite.html">Sprite</a>* sprite)
<a name="l01821"></a>01821  {
<a name="l01822"></a>01822   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01823"></a>01823   q.mPosition[TopLeft].x     = q.mPosition[BottomLeft].x    = x;
<a name="l01824"></a>01824   q.mPosition[TopLeft].y     = q.mPosition[TopRight].y      = y;
<a name="l01825"></a>01825   q.mPosition[TopRight].x    = q.mPosition[BottomRight].x   = x + w;
<a name="l01826"></a>01826   q.mPosition[BottomRight].y = q.mPosition[BottomLeft].y    = y + h;
<a name="l01827"></a>01827   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = Ogre::ColourValue::White;
<a name="l01828"></a>01828   
<a name="l01829"></a>01829   q.mUV[TopLeft].x = sprite-&gt;uvLeft;
<a name="l01830"></a>01830   q.mUV[TopLeft].y = sprite-&gt;uvTop;
<a name="l01831"></a>01831   
<a name="l01832"></a>01832   q.mUV[TopRight].x = sprite-&gt;uvRight;
<a name="l01833"></a>01833   q.mUV[TopRight].y = sprite-&gt;uvTop;
<a name="l01834"></a>01834   
<a name="l01835"></a>01835   q.mUV[BottomLeft].x = sprite-&gt;uvLeft;
<a name="l01836"></a>01836   q.mUV[BottomLeft].y = sprite-&gt;uvBottom;
<a name="l01837"></a>01837   
<a name="l01838"></a>01838   q.mUV[BottomRight].x = sprite-&gt;uvRight;
<a name="l01839"></a>01839   q.mUV[BottomRight].y = sprite-&gt;uvBottom;
<a name="l01840"></a>01840   mQuads.push_back(q);
<a name="l01841"></a>01841   
<a name="l01842"></a>01842  }
<a name="l01843"></a>01843 
<a name="l01844"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a093437d0ae523ab6f4729cbeb5e31dc4">01844</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a093437d0ae523ab6f4729cbeb5e31dc4">QuadList::border</a>(Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, Ogre::Real thickness, <span class="keyword">const</span> Ogre::ColourValue&amp; colour)
<a name="l01845"></a>01845  {
<a name="l01846"></a>01846   <a class="code" href="class_gorilla_1_1_quad_list.html#a093437d0ae523ab6f4729cbeb5e31dc4">border</a>(x,y,w,h,thickness,colour,colour,colour,colour);
<a name="l01847"></a>01847  }
<a name="l01848"></a>01848  
<a name="l01849"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a436262d23a7ec11c3baf8df236adb1f6">01849</a> <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a093437d0ae523ab6f4729cbeb5e31dc4">QuadList::border</a>(Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, Ogre::Real thickness, <span class="keyword">const</span> Ogre::ColourValue&amp; northColour, <span class="keyword">const</span> Ogre::ColourValue&amp; eastColour, <span class="keyword">const</span> Ogre::ColourValue&amp; southColour, <span class="keyword">const</span> Ogre::ColourValue&amp; westColour)
<a name="l01850"></a>01850  {
<a name="l01851"></a>01851   
<a name="l01852"></a>01852   Ogre::Vector2 a(x,y), b(x+w,y), c(x,y+h), d(x+w,y+h),
<a name="l01853"></a>01853                        i = a, j = b, k = c, l = d;
<a name="l01854"></a>01854   i.x -= thickness;    i.y -= thickness;
<a name="l01855"></a>01855   j.x += thickness;    j.y -= thickness;
<a name="l01856"></a>01856   k.x -= thickness;    k.y += thickness;
<a name="l01857"></a>01857   l.x += thickness;    l.y += thickness;
<a name="l01858"></a>01858   
<a name="l01859"></a>01859   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l01860"></a>01860   Ogre::Vector2 uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l01861"></a>01861   
<a name="l01862"></a>01862   <span class="comment">// North</span>
<a name="l01863"></a>01863   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01864"></a>01864   q.mUV[0] = q.mUV[1] = q.mUV[2] = q.mUV[3] = mWhiteUV;
<a name="l01865"></a>01865 
<a name="l01866"></a>01866   <span class="comment">// North</span>
<a name="l01867"></a>01867   q.mPosition[TopLeft] = i;
<a name="l01868"></a>01868   q.mPosition[TopRight] = j;
<a name="l01869"></a>01869   q.mPosition[BottomLeft] = a;
<a name="l01870"></a>01870   q.mPosition[BottomRight] = b;
<a name="l01871"></a>01871   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = northColour;
<a name="l01872"></a>01872   mQuads.push_back(q);
<a name="l01873"></a>01873 
<a name="l01874"></a>01874   <span class="comment">// East</span>
<a name="l01875"></a>01875   q.mPosition[TopLeft] = b;
<a name="l01876"></a>01876   q.mPosition[TopRight] = j;
<a name="l01877"></a>01877   q.mPosition[BottomLeft] = d;
<a name="l01878"></a>01878   q.mPosition[BottomRight] = l;
<a name="l01879"></a>01879   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = eastColour;
<a name="l01880"></a>01880   mQuads.push_back(q);
<a name="l01881"></a>01881   
<a name="l01882"></a>01882   <span class="comment">// South</span>
<a name="l01883"></a>01883   q.mPosition[TopLeft] = c;
<a name="l01884"></a>01884   q.mPosition[TopRight] = d;
<a name="l01885"></a>01885   q.mPosition[BottomLeft] = k;
<a name="l01886"></a>01886   q.mPosition[BottomRight] = l;
<a name="l01887"></a>01887   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = southColour;
<a name="l01888"></a>01888   mQuads.push_back(q);
<a name="l01889"></a>01889   
<a name="l01890"></a>01890   <span class="comment">// West</span>
<a name="l01891"></a>01891   q.mPosition[TopLeft] = i;
<a name="l01892"></a>01892   q.mPosition[TopRight] = a;
<a name="l01893"></a>01893   q.mPosition[BottomLeft] = k;
<a name="l01894"></a>01894   q.mPosition[BottomRight] = c;
<a name="l01895"></a>01895   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = westColour;
<a name="l01896"></a>01896   mQuads.push_back(q);
<a name="l01897"></a>01897   
<a name="l01898"></a>01898  }
<a name="l01899"></a>01899  
<a name="l01900"></a><a class="code" href="class_gorilla_1_1_quad_list.html#aa40c136fe2569ca27f8e86c9d64b96d7">01900</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#aa40c136fe2569ca27f8e86c9d64b96d7">QuadList::glyph</a>(Ogre::uint glyphDataIndex, Ogre::Real x, Ogre::Real y, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> character, <span class="keyword">const</span> Ogre::ColourValue&amp; colour)
<a name="l01901"></a>01901  {
<a name="l01902"></a>01902   <a class="code" href="class_gorilla_1_1_glyph_data.html">GlyphData</a>* glyphData = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#aacdc1d9105e49cbde280fb6830fe3ad2">_getGlyphData</a>(glyphDataIndex);
<a name="l01903"></a>01903   <span class="keywordflow">if</span> (glyphData == 0)
<a name="l01904"></a>01904   {
<a name="l01905"></a>01905 <span class="preprocessor">#if GORILLA_USES_EXCEPTIONS == 1</span>
<a name="l01906"></a>01906 <span class="preprocessor"></span>    OGRE_EXCEPT( Ogre::Exception::ERR_ITEM_NOT_FOUND, <span class="stringliteral">&quot;Glyph data not found&quot;</span>, __FUNC__ );
<a name="l01907"></a>01907 <span class="preprocessor">#else</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
<a name="l01909"></a>01909 <span class="preprocessor">#endif</span>
<a name="l01910"></a>01910 <span class="preprocessor"></span>  }
<a name="l01911"></a>01911   
<a name="l01912"></a>01912   <a class="code" href="class_gorilla_1_1_glyph.html">Glyph</a>* glyph = glyphData-&gt;<a class="code" href="class_gorilla_1_1_glyph_data.html#a17fb2c3de5ad1b62e2e3b89b8677cbf9">getGlyph</a>(character);
<a name="l01913"></a>01913   <span class="keywordflow">if</span> (glyph == 0)
<a name="l01914"></a>01914    <span class="keywordflow">return</span>;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916   y += glyph-&gt;verticalOffset;
<a name="l01917"></a>01917   
<a name="l01918"></a>01918   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01919"></a>01919   q.mPosition[TopLeft].x = x;
<a name="l01920"></a>01920   q.mPosition[TopLeft].y = y;
<a name="l01921"></a>01921   q.mPosition[TopRight].x = x + glyph-&gt;glyphWidth;
<a name="l01922"></a>01922   q.mPosition[TopRight].y = y;
<a name="l01923"></a>01923   q.mPosition[BottomRight].x = x + glyph-&gt;glyphWidth;
<a name="l01924"></a>01924   q.mPosition[BottomRight].y = y + glyph-&gt;glyphHeight;
<a name="l01925"></a>01925   q.mPosition[BottomLeft].x = x;
<a name="l01926"></a>01926   q.mPosition[BottomLeft].y = y + glyph-&gt;glyphHeight;
<a name="l01927"></a>01927   
<a name="l01928"></a>01928   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = colour;
<a name="l01929"></a>01929 
<a name="l01930"></a>01930   q.mUV[TopLeft].x = glyph-&gt;uvLeft;
<a name="l01931"></a>01931   q.mUV[TopLeft].y = glyph-&gt;uvTop;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933   q.mUV[TopRight].x = glyph-&gt;uvRight;
<a name="l01934"></a>01934   q.mUV[TopRight].y = glyph-&gt;uvTop;
<a name="l01935"></a>01935 
<a name="l01936"></a>01936   q.mUV[BottomRight].x = glyph-&gt;uvRight;
<a name="l01937"></a>01937   q.mUV[BottomRight].y = glyph-&gt;uvBottom;
<a name="l01938"></a>01938 
<a name="l01939"></a>01939   q.mUV[BottomLeft].x = glyph-&gt;uvLeft;
<a name="l01940"></a>01940   q.mUV[BottomLeft].y = glyph-&gt;uvBottom;
<a name="l01941"></a>01941   
<a name="l01942"></a>01942   mQuads.push_back(q);
<a name="l01943"></a>01943  }
<a name="l01944"></a>01944  
<a name="l01945"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a9278c9ca127b195550c8672eed53152e">01945</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#aa40c136fe2569ca27f8e86c9d64b96d7">QuadList::glyph</a>(Ogre::uint glyphDataIndex, Ogre::Real x, Ogre::Real y, Ogre::Real w, Ogre::Real h, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> character, <span class="keyword">const</span> Ogre::ColourValue&amp; colour)
<a name="l01946"></a>01946  {
<a name="l01947"></a>01947   <a class="code" href="class_gorilla_1_1_glyph_data.html">GlyphData</a>* glyphData = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#aacdc1d9105e49cbde280fb6830fe3ad2">_getGlyphData</a>(glyphDataIndex);
<a name="l01948"></a>01948   <span class="keywordflow">if</span> (glyphData == 0)
<a name="l01949"></a>01949   {
<a name="l01950"></a>01950 <span class="preprocessor">#if GORILLA_USES_EXCEPTIONS == 1</span>
<a name="l01951"></a>01951 <span class="preprocessor"></span>    OGRE_EXCEPT( Ogre::Exception::ERR_ITEM_NOT_FOUND, <span class="stringliteral">&quot;Glyph data not found&quot;</span>, __FUNC__ );
<a name="l01952"></a>01952 <span class="preprocessor">#else</span>
<a name="l01953"></a>01953 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
<a name="l01954"></a>01954 <span class="preprocessor">#endif</span>
<a name="l01955"></a>01955 <span class="preprocessor"></span>  }
<a name="l01956"></a>01956   
<a name="l01957"></a>01957   <a class="code" href="class_gorilla_1_1_glyph.html">Glyph</a>* glyph = glyphData-&gt;<a class="code" href="class_gorilla_1_1_glyph_data.html#a17fb2c3de5ad1b62e2e3b89b8677cbf9">getGlyph</a>(character);
<a name="l01958"></a>01958   <span class="keywordflow">if</span> (glyph == 0)
<a name="l01959"></a>01959    <span class="keywordflow">return</span>;
<a name="l01960"></a>01960 
<a name="l01961"></a>01961   y += glyph-&gt;verticalOffset;
<a name="l01962"></a>01962   
<a name="l01963"></a>01963   <a class="code" href="struct_gorilla_1_1_quad_list_1_1_quad.html">Quad</a> q;
<a name="l01964"></a>01964   q.mPosition[TopLeft].x = x;
<a name="l01965"></a>01965   q.mPosition[TopLeft].y = y;
<a name="l01966"></a>01966   q.mPosition[TopRight].x = x + w;
<a name="l01967"></a>01967   q.mPosition[TopRight].y = y;
<a name="l01968"></a>01968   q.mPosition[BottomRight].x = x + w;
<a name="l01969"></a>01969   q.mPosition[BottomRight].y = y + h;
<a name="l01970"></a>01970   q.mPosition[BottomLeft].x = x;
<a name="l01971"></a>01971   q.mPosition[BottomLeft].y = y + h;
<a name="l01972"></a>01972   
<a name="l01973"></a>01973   q.mColour[0] = q.mColour[1] = q.mColour[2] = q.mColour[3] = colour;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975   q.mUV[TopLeft].x = glyph-&gt;uvLeft;
<a name="l01976"></a>01976   q.mUV[TopLeft].y = glyph-&gt;uvTop;
<a name="l01977"></a>01977 
<a name="l01978"></a>01978   q.mUV[TopRight].x = glyph-&gt;uvRight;
<a name="l01979"></a>01979   q.mUV[TopRight].y = glyph-&gt;uvTop;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981   q.mUV[BottomRight].x = glyph-&gt;uvRight;
<a name="l01982"></a>01982   q.mUV[BottomRight].y = glyph-&gt;uvBottom;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984   q.mUV[BottomLeft].x = glyph-&gt;uvLeft;
<a name="l01985"></a>01985   q.mUV[BottomLeft].y = glyph-&gt;uvBottom;
<a name="l01986"></a>01986   
<a name="l01987"></a>01987   mQuads.push_back(q);
<a name="l01988"></a>01988  }
<a name="l01989"></a>01989  
<a name="l01990"></a><a class="code" href="class_gorilla_1_1_quad_list.html#a7bd1dc4123e0024a947f767bcfd1a4e7">01990</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_quad_list.html#a7bd1dc4123e0024a947f767bcfd1a4e7">QuadList::end</a>()
<a name="l01991"></a>01991  {
<a name="l01992"></a>01992   mDirty = <span class="keyword">true</span>;
<a name="l01993"></a>01993   mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a08678591ac05c36b68bb2528ad672cab">_markDirty</a>();
<a name="l01994"></a>01994  }
<a name="l01995"></a>01995  
<a name="l01996"></a>01996  <span class="keywordtype">void</span>  QuadList::_redraw()
<a name="l01997"></a>01997  {
<a name="l01998"></a>01998   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l01999"></a>01999    <span class="keywordflow">return</span>;
<a name="l02000"></a>02000   
<a name="l02001"></a>02001   mVertices.remove_all();
<a name="l02002"></a>02002   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l02003"></a>02003   
<a name="l02004"></a>02004   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mQuads.size();i++)
<a name="l02005"></a>02005   {
<a name="l02006"></a>02006    PUSH_QUAD(mVertices, temp, mQuads[i].mPosition, mQuads[i].mColour, mQuads[i].mUV)
<a name="l02007"></a>02007   }
<a name="l02008"></a>02008   
<a name="l02009"></a>02009   mDirty = <span class="keyword">false</span>;
<a name="l02010"></a>02010  }
<a name="l02011"></a>02011  
<a name="l02012"></a>02012  
<a name="l02013"></a>02013  Caption::Caption(Ogre::uint glyphDataIndex, Ogre::Real left, Ogre::Real top, <span class="keyword">const</span> Ogre::String&amp; caption, Layer* layer)
<a name="l02014"></a>02014  : mLayer(layer)
<a name="l02015"></a>02015  {
<a name="l02016"></a>02016   mGlyphData      = mLayer-&gt;_getGlyphData(glyphDataIndex);
<a name="l02017"></a>02017   <span class="keywordflow">if</span> (mGlyphData == 0)
<a name="l02018"></a>02018   {
<a name="l02019"></a>02019     mDirty        = <span class="keyword">false</span>;
<a name="l02020"></a>02020 <span class="preprocessor">#if GORILLA_USES_EXCEPTIONS == 1</span>
<a name="l02021"></a>02021 <span class="preprocessor"></span>    OGRE_EXCEPT( Ogre::Exception::ERR_ITEM_NOT_FOUND, <span class="stringliteral">&quot;Glyph data not found&quot;</span>, __FUNC__ );
<a name="l02022"></a>02022 <span class="preprocessor">#else</span>
<a name="l02023"></a>02023 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
<a name="l02024"></a>02024 <span class="preprocessor">#endif</span>
<a name="l02025"></a>02025 <span class="preprocessor"></span>  }
<a name="l02026"></a>02026   mDirty        = <span class="keyword">true</span>;
<a name="l02027"></a>02027   mLayer-&gt;_markDirty();
<a name="l02028"></a>02028   mLeft           = left;
<a name="l02029"></a>02029   mTop            = top;
<a name="l02030"></a>02030   mWidth          = 0.0f;
<a name="l02031"></a>02031   mHeight         = 0.0f;
<a name="l02032"></a>02032   mText           = caption;
<a name="l02033"></a>02033   mColour         = Ogre::ColourValue::White;
<a name="l02034"></a>02034   mBackground.a   = 0.0f;
<a name="l02035"></a>02035   mAlignment      = TextAlign_Left;
<a name="l02036"></a>02036   mVerticalAlign  = VerticalAlign_Top;
<a name="l02037"></a>02037  }
<a name="l02038"></a>02038 
<a name="l02039"></a>02039  <span class="keywordtype">void</span> Caption::_calculateDrawSize(Ogre::Vector2&amp; retSize)
<a name="l02040"></a>02040  { 
<a name="l02041"></a>02041  
<a name="l02042"></a>02042   Ogre::Real cursor = 0,
<a name="l02043"></a>02043              kerning = 0;
<a name="l02044"></a>02044 
<a name="l02045"></a>02045   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> thisChar = 0, lastChar = 0;
<a name="l02046"></a>02046   Glyph* glyph = 0;
<a name="l02047"></a>02047   retSize.x = 0;
<a name="l02048"></a>02048   retSize.y = mGlyphData-&gt;mLineHeight;
<a name="l02049"></a>02049   
<a name="l02050"></a>02050   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mText.length();i++)
<a name="l02051"></a>02051   {
<a name="l02052"></a>02052    thisChar = mText[i];
<a name="l02053"></a>02053    
<a name="l02054"></a>02054    <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39; &#39;</span>)
<a name="l02055"></a>02055    {
<a name="l02056"></a>02056     lastChar = thisChar;
<a name="l02057"></a>02057     cursor += mGlyphData-&gt;mSpaceLength;
<a name="l02058"></a>02058     <span class="keywordflow">continue</span>;
<a name="l02059"></a>02059    }
<a name="l02060"></a>02060    
<a name="l02061"></a>02061    <span class="keywordflow">if</span> (  thisChar &lt; mGlyphData-&gt;mRangeBegin || thisChar &gt; mGlyphData-&gt;mRangeEnd  )
<a name="l02062"></a>02062    {
<a name="l02063"></a>02063     lastChar = 0;
<a name="l02064"></a>02064     <span class="keywordflow">continue</span>;
<a name="l02065"></a>02065    }
<a name="l02066"></a>02066    
<a name="l02067"></a>02067    glyph = mGlyphData-&gt;getGlyph(thisChar);
<a name="l02068"></a>02068    <span class="keywordflow">if</span> (glyph == 0)
<a name="l02069"></a>02069     <span class="keywordflow">continue</span>;
<a name="l02070"></a>02070    kerning = glyph-&gt;getKerning(lastChar);
<a name="l02071"></a>02071    <span class="keywordflow">if</span> (kerning == 0)
<a name="l02072"></a>02072     kerning = mGlyphData-&gt;mLetterSpacing;
<a name="l02073"></a>02073       
<a name="l02074"></a>02074    cursor  += glyph-&gt;glyphAdvance + kerning;
<a name="l02075"></a>02075    lastChar = thisChar;
<a name="l02076"></a>02076    
<a name="l02077"></a>02077   } <span class="comment">// for</span>
<a name="l02078"></a>02078   
<a name="l02079"></a>02079   retSize.x = cursor - kerning;
<a name="l02080"></a>02080  }
<a name="l02081"></a>02081  
<a name="l02082"></a><a class="code" href="class_gorilla_1_1_caption.html#abf6dc46426bb991fe85641051824d023">02082</a>  <span class="keywordtype">void</span> <a class="code" href="class_gorilla_1_1_caption.html#abf6dc46426bb991fe85641051824d023">Caption::_redraw</a>()
<a name="l02083"></a>02083  {
<a name="l02084"></a>02084   
<a name="l02085"></a>02085   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l02086"></a>02086    <span class="keywordflow">return</span>;
<a name="l02087"></a>02087   
<a name="l02088"></a>02088   mVertices.remove_all();
<a name="l02089"></a>02089   
<a name="l02090"></a>02090   Ogre::Vector2 uv = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#adc8e70b9c2871eab739bc2805e0f2b7c">_getSolidUV</a>();
<a name="l02091"></a>02091   
<a name="l02092"></a>02092   <span class="keywordflow">if</span> (mBackground.a &gt; 0)
<a name="l02093"></a>02093   {
<a name="l02094"></a>02094    Ogre::Vector2  a, b, c, d;
<a name="l02095"></a>02095    a.x = mLeft;  a.y = mTop;
<a name="l02096"></a>02096    b.x = mLeft + mWidth; b.y = mTop;
<a name="l02097"></a>02097    c.x = mLeft;  c.y = mTop + mHeight;
<a name="l02098"></a>02098    d.x = mLeft + mWidth; d.y = c.y = mTop + mHeight;
<a name="l02099"></a>02099    <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l02100"></a>02100    PUSH_TRIANGLE(mVertices, temp, c, b, a, uv, mBackground);
<a name="l02101"></a>02101    PUSH_TRIANGLE(mVertices, temp, c, d, b, uv, mBackground);
<a name="l02102"></a>02102   }
<a name="l02103"></a>02103   
<a name="l02104"></a>02104   Ogre::Real left = 0, top = 0, right = 0, bottom = 0, cursorX = 0, cursorY = 0, kerning = 0, texelOffsetX = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a67d1c135a2083ffc567fbd7143bec6fa">_getTexelX</a>(), texelOffsetY = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#a6510587c01e71557bf1f0a62a7447673">_getTexelY</a>();
<a name="l02105"></a>02105   Ogre::Vector2 knownSize;
<a name="l02106"></a>02106   <a class="code" href="class_gorilla_1_1_glyph.html">Glyph</a>* glyph = 0;
<a name="l02107"></a>02107   
<a name="l02108"></a>02108   <span class="keywordtype">bool</span> clipLeft = <span class="keyword">false</span>, clipRight = <span class="keyword">false</span>;
<a name="l02109"></a>02109   Ogre::Real clipLeftPos = 0, clipRightPos = 0;
<a name="l02110"></a>02110   
<a name="l02111"></a>02111   <span class="keywordflow">if</span> (mAlignment == TextAlign_Left)
<a name="l02112"></a>02112   {
<a name="l02113"></a>02113    cursorX = mLeft;
<a name="l02114"></a>02114    
<a name="l02115"></a>02115    <span class="keywordflow">if</span> (mWidth)
<a name="l02116"></a>02116    {
<a name="l02117"></a>02117     clipRight = <span class="keyword">true</span>;
<a name="l02118"></a>02118     clipRightPos = mLeft + mWidth;
<a name="l02119"></a>02119    }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121   }
<a name="l02122"></a>02122   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAlignment == TextAlign_Centre)
<a name="l02123"></a>02123   {
<a name="l02124"></a>02124    _calculateDrawSize(knownSize);
<a name="l02125"></a>02125    cursorX = mLeft + (mWidth * 0.5f) - (knownSize.x * 0.5f);
<a name="l02126"></a>02126    
<a name="l02127"></a>02127    <span class="keywordflow">if</span> (mWidth)
<a name="l02128"></a>02128    {
<a name="l02129"></a>02129     clipLeft = <span class="keyword">true</span>;
<a name="l02130"></a>02130     clipLeftPos = mLeft;
<a name="l02131"></a>02131     clipRight = <span class="keyword">true</span>;
<a name="l02132"></a>02132     clipRightPos = mLeft + mWidth;
<a name="l02133"></a>02133    }
<a name="l02134"></a>02134    
<a name="l02135"></a>02135   }
<a name="l02136"></a>02136   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAlignment == TextAlign_Right)
<a name="l02137"></a>02137   {
<a name="l02138"></a>02138    _calculateDrawSize(knownSize);
<a name="l02139"></a>02139    cursorX = mLeft + mWidth - knownSize.x;
<a name="l02140"></a>02140    <span class="keywordflow">if</span> (mWidth)
<a name="l02141"></a>02141    {
<a name="l02142"></a>02142     clipLeft = <span class="keyword">true</span>;
<a name="l02143"></a>02143     clipLeftPos = mLeft;
<a name="l02144"></a>02144    }
<a name="l02145"></a>02145   }
<a name="l02146"></a>02146   
<a name="l02147"></a>02147   <span class="keywordflow">if</span> (mVerticalAlign == VerticalAlign_Top)
<a name="l02148"></a>02148    cursorY = mTop;
<a name="l02149"></a>02149   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mVerticalAlign == VerticalAlign_Middle)
<a name="l02150"></a>02150    cursorY = mTop + (mHeight * 0.5) - (mGlyphData-&gt;mLineHeight * 0.5);
<a name="l02151"></a>02151   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mVerticalAlign == VerticalAlign_Bottom)
<a name="l02152"></a>02152    cursorY = mTop +  mHeight - mGlyphData-&gt;mLineHeight;
<a name="l02153"></a>02153   
<a name="l02154"></a>02154   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> thisChar = 0, lastChar = 0;
<a name="l02155"></a>02155   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l02156"></a>02156   mClippedLeftIndex = std::string::npos;
<a name="l02157"></a>02157   mClippedRightIndex = std::string::npos;
<a name="l02158"></a>02158 
<a name="l02159"></a>02159   cursorX = Ogre::Math::Floor( cursorX );
<a name="l02160"></a>02160   cursorY = Ogre::Math::Floor( cursorY );
<a name="l02161"></a>02161   
<a name="l02162"></a>02162   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; mText.size();i++)
<a name="l02163"></a>02163   {
<a name="l02164"></a>02164    thisChar = mText[i];
<a name="l02165"></a>02165    
<a name="l02166"></a>02166    <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39; &#39;</span>)
<a name="l02167"></a>02167    {
<a name="l02168"></a>02168     lastChar = thisChar;
<a name="l02169"></a>02169     cursorX += mGlyphData-&gt;mSpaceLength;
<a name="l02170"></a>02170     <span class="keywordflow">continue</span>;
<a name="l02171"></a>02171    }
<a name="l02172"></a>02172    
<a name="l02173"></a>02173    <span class="keywordflow">if</span> (  thisChar &lt; mGlyphData-&gt;mRangeBegin || thisChar &gt; mGlyphData-&gt;mRangeEnd  )
<a name="l02174"></a>02174    {
<a name="l02175"></a>02175     lastChar = 0;
<a name="l02176"></a>02176     <span class="keywordflow">continue</span>;
<a name="l02177"></a>02177    }
<a name="l02178"></a>02178    
<a name="l02179"></a>02179    glyph = mGlyphData-&gt;<a class="code" href="class_gorilla_1_1_glyph_data.html#a17fb2c3de5ad1b62e2e3b89b8677cbf9">getGlyph</a>(thisChar);
<a name="l02180"></a>02180    <span class="keywordflow">if</span> (glyph == 0)
<a name="l02181"></a>02181     <span class="keywordflow">continue</span>;
<a name="l02182"></a>02182    kerning = glyph-&gt;getKerning(lastChar);
<a name="l02183"></a>02183    <span class="keywordflow">if</span> (kerning == 0)
<a name="l02184"></a>02184     kerning = mGlyphData-&gt;mLetterSpacing;
<a name="l02185"></a>02185    
<a name="l02186"></a>02186    left = cursorX - texelOffsetX;
<a name="l02187"></a>02187    top = cursorY - texelOffsetY + glyph-&gt;verticalOffset;
<a name="l02188"></a>02188    right = left + glyph-&gt;glyphWidth + texelOffsetX;
<a name="l02189"></a>02189    bottom = top + glyph-&gt;glyphHeight + texelOffsetY;
<a name="l02190"></a>02190    
<a name="l02191"></a>02191    <span class="keywordflow">if</span> (clipLeft)
<a name="l02192"></a>02192    {
<a name="l02193"></a>02193     <span class="keywordflow">if</span> (left &lt; clipLeftPos)
<a name="l02194"></a>02194     {
<a name="l02195"></a>02195      <span class="keywordflow">if</span> (mClippedLeftIndex == std::string::npos)
<a name="l02196"></a>02196        mClippedLeftIndex = i;
<a name="l02197"></a>02197      cursorX  += glyph-&gt;glyphAdvance + kerning;
<a name="l02198"></a>02198      lastChar = thisChar;
<a name="l02199"></a>02199      <span class="keywordflow">continue</span>;
<a name="l02200"></a>02200     }
<a name="l02201"></a>02201    }
<a name="l02202"></a>02202    
<a name="l02203"></a>02203    <span class="keywordflow">if</span> (clipRight)
<a name="l02204"></a>02204    {
<a name="l02205"></a>02205     <span class="keywordflow">if</span> (right &gt; clipRightPos)
<a name="l02206"></a>02206     {
<a name="l02207"></a>02207      <span class="keywordflow">if</span> (mClippedRightIndex == std::string::npos)
<a name="l02208"></a>02208        mClippedRightIndex = i;
<a name="l02209"></a>02209      cursorX  += glyph-&gt;glyphAdvance + kerning;
<a name="l02210"></a>02210      lastChar = thisChar;
<a name="l02211"></a>02211      <span class="keywordflow">continue</span>;
<a name="l02212"></a>02212     }
<a name="l02213"></a>02213    }
<a name="l02214"></a>02214    
<a name="l02215"></a>02215    <span class="comment">// Triangle A</span>
<a name="l02216"></a>02216    PUSH_VERTEX(mVertices, temp, left, bottom, glyph-&gt;texCoords[BottomLeft], mColour);  <span class="comment">// Left/Bottom  3</span>
<a name="l02217"></a>02217    PUSH_VERTEX(mVertices, temp, right, top, glyph-&gt;texCoords[TopRight], mColour);    <span class="comment">// Right/Top    1</span>
<a name="l02218"></a>02218    PUSH_VERTEX(mVertices, temp, left, top, glyph-&gt;texCoords[TopLeft], mColour);     <span class="comment">// Left/Top     0</span>
<a name="l02219"></a>02219    
<a name="l02220"></a>02220    <span class="comment">// Triangle B</span>
<a name="l02221"></a>02221    PUSH_VERTEX(mVertices, temp, left, bottom, glyph-&gt;texCoords[BottomLeft], mColour);  <span class="comment">// Left/Bottom  3</span>
<a name="l02222"></a>02222    PUSH_VERTEX(mVertices, temp, right, bottom, glyph-&gt;texCoords[BottomRight], mColour); <span class="comment">// Right/Bottom 2</span>
<a name="l02223"></a>02223    PUSH_VERTEX(mVertices, temp, right, top, glyph-&gt;texCoords[TopRight], mColour);    <span class="comment">// Right/Top    1</span>
<a name="l02224"></a>02224    
<a name="l02225"></a>02225    
<a name="l02226"></a>02226    cursorX  += glyph-&gt;glyphAdvance + kerning;
<a name="l02227"></a>02227    lastChar = thisChar;
<a name="l02228"></a>02228    
<a name="l02229"></a>02229   } <span class="comment">// for</span>
<a name="l02230"></a>02230   
<a name="l02231"></a>02231   
<a name="l02232"></a>02232   mDirty = <span class="keyword">false</span>;
<a name="l02233"></a>02233  }
<a name="l02234"></a>02234  
<a name="l02235"></a>02235  
<a name="l02236"></a>02236  MarkupText::MarkupText(Ogre::uint defaultGlyphIndex, Ogre::Real left, Ogre::Real top, <span class="keyword">const</span> Ogre::String&amp; text, <a class="code" href="class_gorilla_1_1_layer.html">Layer</a>* parent)
<a name="l02237"></a>02237  : mLayer(parent)
<a name="l02238"></a>02238  {
<a name="l02239"></a>02239   mDefaultGlyphData = mLayer-&gt;<a class="code" href="class_gorilla_1_1_layer.html#aacdc1d9105e49cbde280fb6830fe3ad2">_getGlyphData</a>(defaultGlyphIndex);
<a name="l02240"></a>02240 
<a name="l02241"></a>02241   <span class="keywordflow">if</span> (mDefaultGlyphData == 0)
<a name="l02242"></a>02242   {
<a name="l02243"></a>02243    mDirty          = <span class="keyword">false</span>;
<a name="l02244"></a>02244    mTextDirty      = <span class="keyword">false</span>;
<a name="l02245"></a>02245 <span class="preprocessor">#if GORILLA_USES_EXCEPTIONS == 1</span>
<a name="l02246"></a>02246 <span class="preprocessor"></span>    OGRE_EXCEPT( Ogre::Exception::ERR_ITEM_NOT_FOUND, <span class="stringliteral">&quot;Glyph data not found&quot;</span>, __FUNC__ );
<a name="l02247"></a>02247 <span class="preprocessor">#else</span>
<a name="l02248"></a>02248 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
<a name="l02249"></a>02249 <span class="preprocessor">#endif</span>
<a name="l02250"></a>02250 <span class="preprocessor"></span>  }
<a name="l02251"></a>02251 
<a name="l02252"></a>02252   mDirty          = <span class="keyword">true</span>;
<a name="l02253"></a>02253   mTextDirty      = <span class="keyword">true</span>;
<a name="l02254"></a>02254   mLayer-&gt;_markDirty();
<a name="l02255"></a>02255   mLeft           = left;
<a name="l02256"></a>02256   mTop            = top;
<a name="l02257"></a>02257   mWidth          = 0.0f;
<a name="l02258"></a>02258   mHeight         = 0.0f;
<a name="l02259"></a>02259   mText           = text;
<a name="l02260"></a>02260   mBackground.a   = 0.0f;
<a name="l02261"></a>02261 
<a name="l02262"></a>02262  }
<a name="l02263"></a>02263  
<a name="l02264"></a>02264  <span class="keywordtype">void</span> MarkupText::_calculateCharacters()
<a name="l02265"></a>02265  {
<a name="l02266"></a>02266   <span class="keywordflow">if</span> (mTextDirty == <span class="keyword">false</span>)
<a name="l02267"></a>02267    <span class="keywordflow">return</span>;
<a name="l02268"></a>02268   
<a name="l02269"></a>02269   Ogre::Real cursorX = mLeft, cursorY = mTop, kerning = 0, texelOffsetX = mLayer-&gt;_getTexelX(), texelOffsetY = mLayer-&gt;_getTexelY(), right = 0, bottom = 0, left = 0, top = 0;
<a name="l02270"></a>02270   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thisChar = 0, lastChar = 0;
<a name="l02271"></a>02271   Glyph* glyph = 0;
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   mMaxTextWidth = 0;
<a name="l02274"></a>02274   
<a name="l02275"></a>02275   mCharacters.remove_all();
<a name="l02276"></a>02276   
<a name="l02277"></a>02277   <span class="keywordtype">bool</span> markupMode = <span class="keyword">false</span>;
<a name="l02278"></a>02278   Ogre::ColourValue colour = mLayer-&gt;_getMarkupColour(0);
<a name="l02279"></a>02279   <span class="keywordtype">bool</span> fixedWidth = <span class="keyword">false</span>;
<a name="l02280"></a>02280   
<a name="l02281"></a>02281   GlyphData* glyphData = mDefaultGlyphData;
<a name="l02282"></a>02282   Ogre::Real lineHeight = glyphData-&gt;mLineHeight;
<a name="l02283"></a>02283   
<a name="l02284"></a>02284   <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i &lt; mText.length();i++)
<a name="l02285"></a>02285   {
<a name="l02286"></a>02286    
<a name="l02287"></a>02287    thisChar = mText[i];
<a name="l02288"></a>02288    
<a name="l02289"></a>02289    <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39; &#39;</span>)
<a name="l02290"></a>02290    {
<a name="l02291"></a>02291     lastChar = thisChar;
<a name="l02292"></a>02292     cursorX += glyphData-&gt;mSpaceLength;
<a name="l02293"></a>02293     <span class="keywordflow">continue</span>;
<a name="l02294"></a>02294    }
<a name="l02295"></a>02295    
<a name="l02296"></a>02296    <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;\n&#39;</span>)
<a name="l02297"></a>02297    {
<a name="l02298"></a>02298     lastChar = thisChar;
<a name="l02299"></a>02299     cursorX = mLeft;
<a name="l02300"></a>02300     cursorY += lineHeight;
<a name="l02301"></a>02301     lineHeight = glyphData-&gt;mLineHeight;
<a name="l02302"></a>02302     <span class="keywordflow">continue</span>;
<a name="l02303"></a>02303    }
<a name="l02304"></a>02304    
<a name="l02305"></a>02305    <span class="keywordflow">if</span> (  thisChar &lt; glyphData-&gt;mRangeBegin || thisChar &gt; glyphData-&gt;mRangeEnd  )
<a name="l02306"></a>02306    {
<a name="l02307"></a>02307     lastChar = 0;
<a name="l02308"></a>02308     <span class="keywordflow">continue</span>;
<a name="l02309"></a>02309    }
<a name="l02310"></a>02310    
<a name="l02311"></a>02311    <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;%&#39;</span> &amp;&amp; markupMode == <span class="keyword">false</span>)
<a name="l02312"></a>02312    {
<a name="l02313"></a>02313     markupMode = <span class="keyword">true</span>;
<a name="l02314"></a>02314     <span class="keywordflow">continue</span>;
<a name="l02315"></a>02315    }
<a name="l02316"></a>02316    
<a name="l02317"></a>02317    <span class="keywordflow">if</span> (markupMode == <span class="keyword">true</span>)
<a name="l02318"></a>02318    {
<a name="l02319"></a>02319     <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;%&#39;</span>)
<a name="l02320"></a>02320     {
<a name="l02321"></a>02321      <span class="comment">// Escape Character.</span>
<a name="l02322"></a>02322     }
<a name="l02323"></a>02323     <span class="keywordflow">else</span>
<a name="l02324"></a>02324     {
<a name="l02325"></a>02325      markupMode = <span class="keyword">false</span>;
<a name="l02326"></a>02326      
<a name="l02327"></a>02327      <span class="keywordflow">if</span> (thisChar &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; thisChar &lt;= <span class="charliteral">&#39;9&#39;</span>)
<a name="l02328"></a>02328      {
<a name="l02329"></a>02329       colour = mLayer-&gt;_getMarkupColour(thisChar - 48);
<a name="l02330"></a>02330      }
<a name="l02331"></a>02331      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;R&#39;</span> || thisChar == <span class="charliteral">&#39;r&#39;</span>)
<a name="l02332"></a>02332      {
<a name="l02333"></a>02333       colour = mLayer-&gt;_getMarkupColour(0);
<a name="l02334"></a>02334      }
<a name="l02335"></a>02335      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;M&#39;</span> || thisChar == <span class="charliteral">&#39;m&#39;</span>)
<a name="l02336"></a>02336      {
<a name="l02337"></a>02337       fixedWidth = !fixedWidth;
<a name="l02338"></a>02338      }
<a name="l02339"></a>02339      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;@&#39;</span>)
<a name="l02340"></a>02340      {
<a name="l02341"></a>02341       markupMode = <span class="keyword">false</span>;
<a name="l02342"></a>02342       <span class="keywordtype">bool</span> foundIt = <span class="keyword">false</span>;
<a name="l02343"></a>02343       <span class="keywordtype">size_t</span> begin = i;
<a name="l02344"></a>02344       <span class="keywordflow">while</span>(i &lt; mText.size())
<a name="l02345"></a>02345       {
<a name="l02346"></a>02346        <span class="keywordflow">if</span> (mText[i] == <span class="charliteral">&#39;%&#39;</span>)
<a name="l02347"></a>02347        {
<a name="l02348"></a>02348         foundIt = <span class="keyword">true</span>;
<a name="l02349"></a>02349         <span class="keywordflow">break</span>;
<a name="l02350"></a>02350        }
<a name="l02351"></a>02351        i++;
<a name="l02352"></a>02352       }
<a name="l02353"></a>02353       
<a name="l02354"></a>02354       <span class="keywordflow">if</span> (foundIt == <span class="keyword">false</span>)
<a name="l02355"></a>02355        <span class="keywordflow">return</span>;
<a name="l02356"></a>02356       
<a name="l02357"></a>02357       Ogre::uint index = Ogre::StringConverter::parseUnsignedInt(mText.substr(begin+1, i - begin - 1));
<a name="l02358"></a>02358       glyphData = mLayer-&gt;_getGlyphData(index);
<a name="l02359"></a>02359       <span class="keywordflow">if</span> (glyphData == 0)
<a name="l02360"></a>02360        <span class="keywordflow">return</span>;
<a name="l02361"></a>02361       <span class="comment">// TODO: Check against line height?</span>
<a name="l02362"></a>02362       lineHeight = std::max(lineHeight, glyphData-&gt;mLineHeight);
<a name="l02363"></a>02363       <span class="keywordflow">continue</span>;
<a name="l02364"></a>02364      }
<a name="l02365"></a>02365      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thisChar == <span class="charliteral">&#39;:&#39;</span>)
<a name="l02366"></a>02366      {
<a name="l02367"></a>02367       markupMode = <span class="keyword">false</span>;
<a name="l02368"></a>02368       <span class="keywordtype">bool</span> foundIt = <span class="keyword">false</span>;
<a name="l02369"></a>02369       <span class="keywordtype">size_t</span> begin = i;
<a name="l02370"></a>02370       <span class="keywordflow">while</span>(i &lt; mText.size())
<a name="l02371"></a>02371       {
<a name="l02372"></a>02372        <span class="keywordflow">if</span> (mText[i] == <span class="charliteral">&#39;%&#39;</span>)
<a name="l02373"></a>02373        {
<a name="l02374"></a>02374         foundIt = <span class="keyword">true</span>;
<a name="l02375"></a>02375         <span class="keywordflow">break</span>;
<a name="l02376"></a>02376        }
<a name="l02377"></a>02377        i++;
<a name="l02378"></a>02378       }
<a name="l02379"></a>02379       
<a name="l02380"></a>02380       <span class="keywordflow">if</span> (foundIt == <span class="keyword">false</span>)
<a name="l02381"></a>02381        <span class="keywordflow">return</span>;
<a name="l02382"></a>02382       
<a name="l02383"></a>02383       Ogre::String sprite_name = mText.substr(begin+1, i - begin - 1);
<a name="l02384"></a>02384       
<a name="l02385"></a>02385       Sprite* sprite = mLayer-&gt;_getSprite(sprite_name);
<a name="l02386"></a>02386       <span class="keywordflow">if</span> (sprite == 0)
<a name="l02387"></a>02387        <span class="keywordflow">continue</span>;
<a name="l02388"></a>02388       
<a name="l02389"></a>02389       left = cursorX - texelOffsetX;
<a name="l02390"></a>02390       top = cursorY - texelOffsetY + glyph-&gt;verticalOffset;
<a name="l02391"></a>02391       right = left + sprite-&gt;spriteWidth + texelOffsetX;
<a name="l02392"></a>02392       bottom = top + sprite-&gt;spriteHeight + texelOffsetY;
<a name="l02393"></a>02393       
<a name="l02394"></a>02394       Character c;
<a name="l02395"></a>02395       c.mIndex = i;
<a name="l02396"></a>02396       c.mPosition[TopLeft].x = left;
<a name="l02397"></a>02397       c.mPosition[TopLeft].y = top;
<a name="l02398"></a>02398       c.mPosition[TopRight].x = right;
<a name="l02399"></a>02399       c.mPosition[TopRight].y = top;
<a name="l02400"></a>02400       c.mPosition[BottomLeft].x = left;
<a name="l02401"></a>02401       c.mPosition[BottomLeft].y = bottom;
<a name="l02402"></a>02402       c.mPosition[BottomRight].x = right;
<a name="l02403"></a>02403       c.mPosition[BottomRight].y = bottom;
<a name="l02404"></a>02404       c.mUV[0] = sprite-&gt;texCoords[0];
<a name="l02405"></a>02405       c.mUV[1] = sprite-&gt;texCoords[1];
<a name="l02406"></a>02406       c.mUV[2] = sprite-&gt;texCoords[2];
<a name="l02407"></a>02407       c.mUV[3] = sprite-&gt;texCoords[3];
<a name="l02408"></a>02408       c.mColour = colour;
<a name="l02409"></a>02409       
<a name="l02410"></a>02410       mCharacters.push_back(c);
<a name="l02411"></a>02411       
<a name="l02412"></a>02412       cursorX  += sprite-&gt;spriteWidth;
<a name="l02413"></a>02413       
<a name="l02414"></a>02414       lineHeight = std::max(lineHeight, sprite-&gt;spriteHeight);
<a name="l02415"></a>02415       
<a name="l02416"></a>02416       <span class="keywordflow">continue</span>;
<a name="l02417"></a>02417      }
<a name="l02418"></a>02418      
<a name="l02419"></a>02419 
<a name="l02420"></a>02420      <span class="keywordflow">continue</span>;
<a name="l02421"></a>02421     }
<a name="l02422"></a>02422     markupMode = <span class="keyword">false</span>;
<a name="l02423"></a>02423    }
<a name="l02424"></a>02424    
<a name="l02425"></a>02425    glyph = glyphData-&gt;getGlyph(thisChar);
<a name="l02426"></a>02426    
<a name="l02427"></a>02427    <span class="keywordflow">if</span> (!fixedWidth)
<a name="l02428"></a>02428    {
<a name="l02429"></a>02429     kerning = glyph-&gt;getKerning(lastChar);
<a name="l02430"></a>02430     <span class="keywordflow">if</span> (kerning == 0)
<a name="l02431"></a>02431      kerning = glyphData-&gt;mLetterSpacing;
<a name="l02432"></a>02432    }
<a name="l02433"></a>02433    
<a name="l02434"></a>02434    left = cursorX;
<a name="l02435"></a>02435    top = cursorY + glyph-&gt;verticalOffset;
<a name="l02436"></a>02436    right = cursorX + glyph-&gt;glyphWidth + texelOffsetX;
<a name="l02437"></a>02437    bottom = top + glyph-&gt;glyphHeight + texelOffsetY;
<a name="l02438"></a>02438    
<a name="l02439"></a>02439    Character c;
<a name="l02440"></a>02440    c.mIndex = i;
<a name="l02441"></a>02441    c.mPosition[TopLeft].x = left;
<a name="l02442"></a>02442    c.mPosition[TopLeft].y = top;
<a name="l02443"></a>02443    c.mPosition[TopRight].x = right;
<a name="l02444"></a>02444    c.mPosition[TopRight].y = top;
<a name="l02445"></a>02445    c.mPosition[BottomLeft].x = left;
<a name="l02446"></a>02446    c.mPosition[BottomLeft].y = bottom;
<a name="l02447"></a>02447    c.mPosition[BottomRight].x = right;
<a name="l02448"></a>02448    c.mPosition[BottomRight].y = bottom;
<a name="l02449"></a>02449    c.mUV[0] = glyph-&gt;texCoords[0];
<a name="l02450"></a>02450    c.mUV[1] = glyph-&gt;texCoords[1];
<a name="l02451"></a>02451    c.mUV[2] = glyph-&gt;texCoords[2];
<a name="l02452"></a>02452    c.mUV[3] = glyph-&gt;texCoords[3];
<a name="l02453"></a>02453    c.mColour = colour;
<a name="l02454"></a>02454    
<a name="l02455"></a>02455    mCharacters.push_back(c);
<a name="l02456"></a>02456    
<a name="l02457"></a>02457    <span class="keywordflow">if</span> (fixedWidth)
<a name="l02458"></a>02458      cursorX  += glyphData-&gt;mMonoWidth;
<a name="l02459"></a>02459    <span class="keywordflow">else</span>
<a name="l02460"></a>02460      cursorX  += glyph-&gt;glyphAdvance + kerning;
<a name="l02461"></a>02461    
<a name="l02462"></a>02462    <span class="keywordflow">if</span>( cursorX &gt; mMaxTextWidth )
<a name="l02463"></a>02463        mMaxTextWidth = cursorX;
<a name="l02464"></a>02464 
<a name="l02465"></a>02465    lastChar = thisChar;
<a name="l02466"></a>02466   }
<a name="l02467"></a>02467 
<a name="l02468"></a>02468   mMaxTextWidth -= mLeft;
<a name="l02469"></a>02469   
<a name="l02470"></a>02470   mTextDirty = <span class="keyword">false</span>;
<a name="l02471"></a>02471  }
<a name="l02472"></a>02472  
<a name="l02473"></a><a class="code" href="class_gorilla_1_1_markup_text.html#aafba6f5b9584fc38622ffdcc5e73326a">02473</a>  <span class="keywordtype">void</span>  <a class="code" href="class_gorilla_1_1_markup_text.html#aafba6f5b9584fc38622ffdcc5e73326a">MarkupText::_redraw</a>()
<a name="l02474"></a>02474  {
<a name="l02475"></a>02475   
<a name="l02476"></a>02476   <span class="keywordflow">if</span> (mDirty == <span class="keyword">false</span>)
<a name="l02477"></a>02477    <span class="keywordflow">return</span>;
<a name="l02478"></a>02478   
<a name="l02479"></a>02479   mVertices.remove_all();
<a name="l02480"></a>02480   
<a name="l02481"></a>02481   <a class="code" href="struct_gorilla_1_1_vertex.html">Vertex</a> temp;
<a name="l02482"></a>02482   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; mCharacters.size();i++)
<a name="l02483"></a>02483   {
<a name="l02484"></a>02484    PUSH_QUAD2(mVertices, temp, mCharacters[i].mPosition, mCharacters[i].mColour, mCharacters[i].mUV);
<a name="l02485"></a>02485   }
<a name="l02486"></a>02486   
<a name="l02487"></a>02487   mDirty = <span class="keyword">false</span>;
<a name="l02488"></a>02488  }
<a name="l02489"></a>02489 
<a name="l02490"></a>02490 } <span class="comment">// namespace Gorilla</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 8 21:25:19 2011 for OreWar by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
